[
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/medsci_course/",
	"title": "Medical Sciences Course",
	"tags": [],
	"description": "",
	"content": "Overview and Support Welcome to the Online Scientific Computing MATLAB course. This course aims to give students a good understanding of the MATLAB programming language, and the use of MATLAB in data analysis, image analysis, numerical calculus, linear algebra and the solution of ODEs. Where applicable, a revision of elements of A-level mathematics needed for these areas is provided. Elements of software engineering are covered to give students the ability to write well-structured code, as well as how to use MATLAB to present their work using movies or Graphical User Interfaces (GUIs).\nThe course runs from 09 May 2022 to 17 June 2022 and is supported via an MS Teams Team, which you will have already been added to. The course leader, Fergus Cooper, will be available to help you with the course content and general MATLAB enquiries, and will respond to messages on the MS Teams Team throughout the course on a first come first served basis.\nIf you have any questions then contact the course tutor via the MS Teams Team.\nThe Course The course is broken down into a number of units, each one is designed to take approximately one day to complete, however this will depend greatly on your background.\nThe first unit is much shorter and gives you an introduction to the course. You should look at this now to make sure that you have everything you need to begin the course.\nUnit 0: Course introduction The remainder of the course is split into two sections: compulsory units, which contain general concepts of MATLAB and A-level mathematics; and optional units, which are units that will require some detailed mathematical knowledge.\nYou should work through the units in your own time. Click on the links below to view the units.\nCompulsory units: In order to complete the course you should complete the following 3 units and submit the associated assessments given below.\n Unit 1: Basic introduction to MATLAB Unit 2: Data and image analysis Unit 3: Basic calculus  Optional Units: These units are optional and are intended for students with a background in the physical sciences. However, background material is given where needed, so the units should also be accessible to non specialists.\n Unit 4: Linear algebra Unit 5: Solving ODEs Unit 6: Software engineering  If you would like advice on which optional units to take then contact the course leader via the MS Teams Team.\nAssessments Unit 1: Basic introduction to MATLAB Write a MATLAB function which calculates the mean and median of a set of numbers.\n The function should take in a vector of numbers and return both the mean and the median of the numbers. You cannot use the inbuilt functions mean or median. You might find the inbuilt function sort useful. You should be able to call the function by using the command [mean_x, median_x] = MeanMedian(x); You should then have two new variables, mean_x and median_x: check this with the command whos. To test your function try it on  the vector x=[1 2 3 1 2 3 3 3] where you should get mean_x=2.25 and median_x=2.5. the vector x=[5 2 -4] where you should get mean_x=1 and median_x=2.   Make sure that your file contains some comments which explain how it works.  You should submit the .m file created for this assessment.\nUnit 2: Data and image analysis The file data.txt (right click to save to your computer) contains some data in the form:\nx1 y1 x2 y2 x3 y3 ... Write a MATLAB script that:\n Loads the data into MATLAB. Calculates the cubic fit to the data xi yi. (You may find the command polyfit useful.) Evaluates the fitted polyniomial at the data points xi. (You might find the command polyval useful.) Saves the data back to file in the same form (i.e as a text file with the name datafit.txt with two columns xi zi where zi is the value of the fitted polynomial at the points xi). You will use this file in the next assessment. You might find the command \u0026ldquo;save('datafit.txt', 'datafit', '-ASCII')\u0026rdquo; useful. Plots the original data and the fitted polynomial on the same graph, along with suitable legend and labelled axes. The original data are discrete points so should be plotted as dots or crosses. The fitted polynomial is continuous so should be plotted as a line. Saves the plot as a .png file.  Note that all these steps should be done automatically in the script. You should submit the script and the resulting .png file for this assessment.\nUnit 3: Basic calculus Write a MATLAB script to:\n Load the data saved from the exercise from Unit 2 (datafit.txt). Calculate the rate of change of the process (i.e. calculate the derivative). You should do this using the difference formulae given in the Unit. Calculate the maximum and minimum of the rate of change, and where these occur. Note that the magnitude of the rate of change is important: a negative gradient may still have a large slope. The minimum rate of change occurs where the slope is flattest and not necessarily where it has a negative gradient. Calculate the area under the curve (i.e. integrate it), using the trapezium rule.  For this assessment you should submit the script, the value of the maximum and minimum rate of change (together with where they occur) and the area under the curve.\nOptional units and beyond There are no assessments required for the optional units. However, support for the exercises will still be provided via the MS Teams Team. If you finish the compulsory units and would like support on your own project during the course then you can feel free to contact the course leader.\nSubmission Each student will have a private channel on the MS Teams Team for one-to-one contact with the course leader. All files for assessment should be added to the conversation on that private channel by the final day of the course at the latest.\nYou will need to have submitted the required material for all three compulsory assessments before the course ends in order to complete the course. You can submit the assessments whenever you like throughout the course, however, and you are encouraged to submit the assessments as soon as you have completed them, so that you can receive feedback as you go through the course.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/",
	"title": "Course introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 0 Course introduction "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/",
	"title": "Basic introduction to MATLAB",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basic introduction to MATLAB "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/",
	"title": "Data and image analysis",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Data and image analysis "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/",
	"title": "Basic calculus",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Basic calculus "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/",
	"title": "Linear algebra",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Linear algebra "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/",
	"title": "Solving ODEs",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Solving ODEs "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/",
	"title": "Software engineering",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Software engineering "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Scientific Computing in MATLAB An online course from the DTC at the University of Oxford "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/01_course_overview/",
	"title": "Course Overview",
	"tags": [],
	"description": "",
	"content": "Welcome to \u0026lsquo;Scientific Computing in MATLAB\u0026rsquo;. We are delighted you have chosen this course and hope it will meet your expectations.\nIn this preliminary unit we shall be looking at:\n communications managing your learning activities.  If you are already familiar with online study, you will be able to skip through these sessions quickly and get onto the real stuff. If you are not, it may answer a few of your questions. If you have any remaining questions contact your tutor who will be happy to help.\nIf you have questions relating to the academic content or learning, please contact your course tutor, who will introduce him-or herself to you via email.\nMathematical prerequisites The course is a mathematically based one and we assume that you have studied mathematics to A level or equivalent. You should be familiar with the ideas of vectors, matrices, differentiation and integration along with basic probability and statistics. There will be reminders of the key mathematical ideas where they are used, along with appropriate references, but we will not be explaining everything from scratch.\nRequired reading There is no required reading for this course, which is relatively self-contained. References are given throughout the course where you can find more information on particular topics, many of which are online resources or help files. There are however certain places where no appropriate online sources are available, so we have given references to appropriate books.\nRequired software For this course you will need access to a computer with the MATLAB software installed. Section 0.3 contains details on how to get MATLAB. If you already have access to MATLAB then you can skip this section.\nUnits This course is divided into six units, each of which is designed to take between a few hours and a few days to cover, depending on your prior programming and mathematics experience. The units are as follows:\n Unit 1: Basic introduction to MATLAB Unit 2: Data analysis, image analysis and basic statistics in MATLAB Unit 3: Basic calculus in MATLAB Unit 4: Linear algebra in MATLAB Unit 5: Solving ODEs in MATLAB Unit 6: Software engineering and scientific computing  Each unit consists of:\n an introduction giving you an outline of the topic covered in the unit and its learning objectives information about the topic you are studying, giving you the context within which your reading should make sense a number of activities, some of which are pen and paper exercises, and the majority of which are MATLAB exercises (and both types contain hints and solutions) recommended resources for further exploration.  Learning expectations Depending on how the course you are taking is structured, you may be working full-time on this course, or only for a few hours a week. You will find that a lot of that time is spent working on the exercises in MATLAB and – we hope – discussing the issues with your fellow students. This will help you to share ideas and experiences and learn from others as you progress through the course.\nIn undertaking this course, you are committing yourself to:\n regularly reading the course materials working through all activities, which is especially important as this is the main mechanism for learning on this course completing the final assignment.  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives In this introductory unit you will learn the basics of MATLAB, from how to start MATLAB through to how to use it to write simple code and to use basic graphic capabilities of MATLAB. The aim of this unit is for you to acquire a familiarity with MATLAB and to learn a few basic commands.\nWhen you see things written in typewriter font as in this for example, you should type these commands into the MATLAB command window. his unit consists mostly of walkthroughs which introduce you to the commands that you will use throughout the course; be sure to enter these commands into MATLAB as you go through the walkthroughs. If you come across a command that you don\u0026rsquo;t know, use the inbuilt MATLAB help files (which we will explain how to use below) to find out what it does.\nThis course was developed using MATLAB on Microsoft Windows, but MATLAB is the same regardless of the operating system you are using. Some aspects of the appearance may vary between operating systems, but all functionality should be the same.\nReading list There is no specific reading list for this unit but the following resources may be useful.\n the MATLAB help system (found by typing \u0026lsquo;doc\u0026rsquo; on the command line), which is explained in one of the first screens the online MATLAB documentation The book MATLAB Primer, by Timothy A. Davis and Kermit Sigmon  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives Data analysis and statistics are the cornerstones of most quantitative disciplines. MATLAB has many inbuilt commands for calculating statistics from large data-sets. In this unit we will look at some of MATLAB’s inbuilt statistical commands and also use MATLAB to perform some common data analysis techniques. By the end of the unit you should be able to perform simple statistical analyses on data-sets and have gained an understanding of how to use MATLAB to generate various types of random samples. We will also learn how to read data (including images) into MATLAB, how to display these data, how to process these data and how to write the data back to a file.\nReading list In order to understand the material in this unit you should know some probability and statistics. We assume that you have an A level understanding of probability and statistics.\nThe following are suitable introductory reference sources on probability and statistics. Where needed, references for more advanced material will be given.\n Any A level or undergraduate introduction to probability or statistics The statistics wikibook Chapter 24 (in the ninth edition) of Advanced Engineering Mathematics by Erwin Kreyszig. (This is a huge book but you should be able to find a copy in your library.)  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives The solution of systems of linear equations forms the basis of many techniques in applied mathematics and statistics, so numerical linear algebra forms perhaps the most important set of tools in scientific programming. MATLAB has been developed specifically to handle matrix and vector operations (hence its name – a portmanteau of \u0026lsquo;matrix\u0026rsquo; and \u0026lsquo;laboratory\u0026rsquo;). It has some particularly efficient and effective inbuilt commands to enable the easy manipulation of matrices and vectors, and very straightforward solutions of linear systems (and hence of nonlinear systems).\nThe aim of this unit is to show you how to use the inbuilt functionality to manipulate vectors and matrices and to solve the linear system $A\\mathbf{x}=\\mathbf{b}$. More importantly, you will see which methods are appropriate in which situation.\nThe unit begins with a walkthrough of the basics of matrix manipulation in MATLAB which will give you a good introduction to its inbuilt functionality. There are some exercises at the end to test your understanding. The second half of the unit is concerned with the solution of the linear system $A\\mathbf{x}=\\mathbf{b}$, and will require you to use the basic commands you learned in the first half in order to solve some typical linear systems that arise in solving partial differential equations. (Note: You will not need to understand where the linear systems come from, but they are from a \u0026lsquo;real world problem\u0026rsquo; so they will give you an insight into the power of MATLAB.)\nThis unit assumes you are already familiar with manipulating vectors and matrices, and with concepts such as eigenvalues and determinants. This material is covered at A level and in the first year of undergraduate mathematics degrees, so any introductory linear algebra book will contain the material. Some examples are listed below.\nReading list There are many undergraduate texts on linear algebra, which are mainly theoretical. One that is particularly recommended is Linear Algebra and its Applications by Gilbert Strang. Again, all ideas will be introduced where they are needed, and references will be given.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives As you will have found out by now, it is important to produce well-structured and efficient code. This unit contains exercises designed to show you how to do this. It is also important to be able to represent the results of your work in the best possible way. In this unit you will therefore also learn how to construct a simple Graphical User Interface (GUI) for your code and how to produce movies in MATLAB to present your results.\nThe time you spend typing is a tiny fraction of the time you spend coding. Much of your time will be spent:\n designing; testing (making sure your code does what it\u0026rsquo;s meant to do); debugging (fixing problems); refactoring (rewriting elements of the code without changing what they do); or enhancing (improving the code).  The aim of this unit is to show you techniques to improve your code in order to make it more efficient and user friendly.\nReading list Much of this unit is based on the following three online sources:\n \u0026lsquo;Writing Fast MATLAB Code\u0026rsquo;: download pdf and accompanying license The Software carpentry website: https://software-carpentry.org/lessons/ An article on coding styles: http://queue.acm.org/detail.cfm?id=1039535  The \u0026lsquo;Writing Fast MATLAB Code\u0026rsquo; guide will be particularly useful as you begin to write your own code. I advise downloading a copy now to look at as you go throughout the unit. While fairly old now, the techniques described are nonetheless very relevant.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/01_introduction_and_definitions/",
	"title": "Introduction and definitions",
	"tags": [],
	"description": "",
	"content": "Learning objectives The purpose of this unit is to use MATLAB to carry out many of the analytical mathematical techniques that you know. We will look at traditional methods of numerical differentiation and integration as well as root-finding algorithms. Also included is a section on Fourier series which allow discontinuous functions to be approximated by sums of continuous functions. The aim of the unit is to show you how to use MATLAB to undertake all these operations and also to give you practice in creating MATLAB functions.\nReading list The best book for descriptions of the numerical methods used here is Advanced Engineering Mathematics by Erwin Kreyszig.\nThere will be appropriate references wherever new numerical ideas are introduced.\nIf you do not know the underlying ideas of differentiation and integration then you can find details in:\n any A level textbook any first-year undergraduate calculus textbook the Calculus Wikibook  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/01_introduction_and_definitions/",
	"title": "Introduction and definitions",
	"tags": [],
	"description": "",
	"content": "Learning objectives Systems of Ordinary Differential Equations (ODEs) are used to model many physical and biological systems. MATLAB contains a collection of ODE solvers, which are ideal for investigating such systems. The aim of this unit is to enable you to understand and use these solvers. In addition you will see how to tell which solver is appropriate in which situation.\nThe unit begins with a revision of analytical techniques for solving ODEs before moving on to numerical methods, such as Euler\u0026rsquo;s method. You will learn how to use the inbuilt MATLAB functions to solve systems of ODEs with initial and boundary conditions.\nReading list  Advanced Engineering Mathematics by Erwin Kreyszig, Chapters 1 and 2, for the theory of ODEs. http://mathworld.wolfram.com/First-OrderOrdinaryDifferentialEquation.html will cover all the theory you need. Matlab help files doc ode45, doc bvp4c  Definitions and notation  Differential Equation – This is an equation containing variables and their derivatives. ODE – Ordinary Differential Equation. This is a differential equation where the derivatives of the dependent variable (usually $y$ or $x$) are with respect to only one independent variable, usually $x$ or $t$. Order of ODE – order of the highest derivative. Therefore a first-order ODE is of the form: $$\\frac{dy}{dx}=f(x,y).$$ Notation: the following shorthand for derivatives will be used throughout the unit: $$y'=\\frac{dy}{dx}\\qquad\\mbox{and}\\qquad\\dot{y}=\\frac{dy}{dt}.$$  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/02_analytical_methods_1st_order/",
	"title": "Analytical methods: 1st order",
	"tags": [],
	"description": "",
	"content": "Before moving on to numerical methods for the solution of ODEs we begin by revising basic analytical techniques for solving ODEs that you will of seen at undergraduate level.\nSeparation of variables/separable solutions If your equation is of the form $$ \\frac{dy}{dx}=\\frac{f(x)}{g(y)} \\,, $$ then it can be reformulated as $$\\int g(y)\\,dy = \\int f(x)\\,dx + C \\,, $$ where $C \\in \\Re$ is a constant of integration. This can be solved by integration, either directly or by substitution, to give a relation between $y$ and $x$. The following example will show you how to use to use the separation of variables to solve a first-order ODE.\nWalkthrough We wish to solve $$ \\frac{dy}{dx} = \\frac{x}{y} \\,, $$ subject to $ y(0) = 1 $. The equation can be reformulated as $$ \\int y\\,dy = \\int x\\,dx + C \\,, $$ which can be solved to give $$ \\frac{y^2}{2} = \\frac{x^2}{2} + C \\,,$$ which simplifies to $$ y = \\pm \\sqrt{x^2 + A} \\,, $$ where $ A = 2C $. This is the general solution to the differential equation. We now need to apply the initial condition $y(0)=1$. $$ 1 = y(0) = \\pm\\sqrt{A} \\,, $$ Therefore $A=1$, and we take the positive root. The solution is $y = \\sqrt{x^2+1}$.\nIntegrating factors If your equation is of the form $$ \\frac{dy}{dx} + f(x)y = g(x) \\, $$ then it can be reformulated by introducing an integrating factor. The integrating factor for the above equation is defined as $$ \\varphi(x) = e^{\\int f(x) \\,dx} \\,, $$ (Note: that this is not unique as any multiple would also be an integrating factor). In order to solve the original equation we multiply through by the integrating factor to give $$ \\varphi(x)\\frac{dy}{dx} + \\varphi(x)f(x)y(x) = \\varphi(x)g(x) \\,, $$ by construction of the integrating factor $$ \\frac{d\\varphi}{dx} = \\varphi(x)f(x) \\,. $$ The original equation can be written as $$ \\frac{d}{dx}\\left(\\varphi(x)y(x)\\right) = \\varphi(x)g(x) \\,.$$\nThis can be solved by integration of the right hand side, either directly or by substitution. The solution is $$ y(x) = \\frac{\\int\\varphi(x)g(x)\\,dx}{\\varphi(x)} $$ Note: You need to be careful to consider where the solutions exist, that is, you need $\\varphi(x) \\neq 0$. Therefore no solutions exist for $x$ such that $\\varphi(x) \\neq 0$. The following example will show you how to use integrating factors to solve a first-order ODE.\nWalkthrough We wish to solve $$ \\frac{dy}{dx} + \\frac{y}{x} = 1 \\,, $$ subject to $y(1) = 0$. The integrating factor for this equation is given by $$ \\varphi(x) = e^{\\int\\frac{1}{x}\\,dx} = x \\,. $$ Therefore the original equation may be written as $$ \\frac{d}{dx}\\left(xy\\right) = x \\,. $$ Integrating the right-hand side gives $$ y(x) = \\frac{x}{2} + \\frac{C}{x} \\,, $$ where $C \\in \\Re$ is a constant of integration, and $x \\neq 0$. This is the general solution to the differential equation. We now need to apply the initial condition $y(1) = 0$. $$ 0 = \\frac{1}{2} + \\frac{C}{1} \\,.$$ Therefore $ C = \\frac{-1}{2} $, and the solution is $ y(x) = \\frac{x}{2} - \\frac{1}{2x}$, valid for $x\u0026gt;0.$\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/02_course_activities/",
	"title": "Course Activities",
	"tags": [],
	"description": "",
	"content": "The main teaching mechanism on this course is through activities and exercises. Each unit is composed of a number of such activities which will not only introduce the material to you but also enable you to demonstrate your understanding (or to express your lack of understanding – something you should never be afraid to do).\nRegular activities and resources There are several kinds of activity that you will be asked to complete while on this course. Some of these will be ongoing throughout the course, whereas others will relate to the topic of a particular week. Activity types include:\nReading: Doing this lets you explore the content of the course. Usually you will receive guidance about things you should be considering as you do the reading to help you get the most from it.\nIndividual activities: These will help you to consolidate the learning from your reading and further explore the ideas in the course. Much of the work you undertake on your own will feed into your assignments.\nThe activities are broken up into the following two categories:\nWalkthroughs: In each of these, you will be taken through an application of MATLAB. You should type all commands given into the MATLAB command window as you work your way through the activity.\nProblems: You will be given a problem to solve using MATLAB (and, very occasionally, pen and paper). This will require the creation of a figure or the development of an appropriate MATLAB function. Hints and solutions will be given.\nThe work you do for many of the exercises on this course will be directly useful in the assignment, which will therefore be much less onerous if you have completed the activities as you go along.\nCode and Mathematics Code will be written in typewriter font, this for example, and you should type these commands into the MATLAB command window when you see them, to see what they do.\nLonger code blocks will appear like this:\nb=ones(500,1); tic, x1=A\\b; toc tic, x2=B\\b; toc Mathematics will be presented in maths font, i.e. $\\Psi(\\mathbf{r},t)$, and longer equations may appear on on their own line, such as:\n$$i\\hbar\\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) = \\left [ \\frac{-\\hbar^2}{2\\mu}\\nabla^2 + V(\\mathbf{r},t)\\right ] \\Psi(\\mathbf{r},t).$$\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/02_formatting_code_part_1/",
	"title": "Formatting code: part 1",
	"tags": [],
	"description": "",
	"content": "This section is based on the https://software-carpentry.org/ course and the article on coding style https://queue.acm.org/detail.cfm?id=1039535. Emphasis has been put on how you use these ideas in MATLAB, however, a lot of the ideas you will see here are applicable in any programming language.\nWhy we write code The main reasons we write code are:\n to design solutions to problems; to communicate our designs to people; and to get a computer to implement our design.  Good design Source code is written for humans to read – and not for computers, which only care about 0s and 1s. Therefore we want to provide as much information as possible to the next person who reads the code – even if that person is you. Code you wrote more than about three weeks ago may as well have been written by somebody else.\nConsistency, in the form of conventions, gives lots of extra information. Always try to use descriptive names for functions and variables as the names given to things are the most visible clue to their purpose. Make them both meaningful and readable.\nYou should aim to be as clear as you can, even if it takes more lines of code.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/02_numerical_differentiation/",
	"title": "Numerical differentiation",
	"tags": [],
	"description": "",
	"content": "You should already be familiar with the idea of analytical differentiation and be able to differentiate simple functions like $y=x^n$ and $y=sin(x)$. If you don’t know how to do this, look it up now in any A level textbook or the relevant section of the Calculus Wikibook.\nSometimes functions are highly non-linear and a closed form for the derivative may be difficult to calculate. For example\n$$y=x^{\\ln x}$$\nAlternatively, $y$ can be defined as the solution to an equation, so we can not calculate a closed form for $y=f(x)$ to which the traditional rules of differentiation may be applied. In such cases we may calculate a numerical approximation for the derivative using the following difference formulae.\nSummary of mathematics used Suppose $y=f(x)$. Let the points $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced over the interval $\\left[a,b\\right]$, and let $h=\\frac{1}{N}\\left(x_N−x_0\\right)=x_{i+1}−x_i$. Now let $y_i=f(x_i)$.\n The forward difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}-y_i}{h}$$ The backward difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_i−y_{i−1}}{h}$$ The central difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}−y_{i−1}}{2h}$$ An approximation to the second derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2}$$  Where $h$ is assumed to be small, the smaller $h$ is, the better the approximation becomes. The derivation of these forms is undertaken in the next exercise.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/02_simple_summary_statistics/",
	"title": "Simple summary statistics",
	"tags": [],
	"description": "",
	"content": "Useful MATLAB commands There are many inbuilt MATLAB commands for calculating statistical properties of data. Some of them are listed below:\n max - returns the maximum value of an array. min – returns the minimum value of an array. mean – returns the mean (average) value of the array. median – returns the median value of an array. mode – returns the mode value of an array. std – returns the standard deviation of an array. var – returns the variance of an array. hist – plots the values in the array as a histogram. sort – sorts the elements of the array in ascending order. sum – returns the sum of all the elements of the array. rand – generates uniformly distributed random numbers. randn – generates normally distributed random numbers with mean 0 and variance 1.  The following activities will help you use these basic commands.\nQuestion Look at the MATLAB help files (doc max etc) for each of the above commands and apply them all (except rand and randn) to the following vector:\nx = [3 -47 -6 -29 37 -22 -7 12 -7 -18 -53 -12 34 12 -35 28 -5 22 4 -70 -32 47 -6 -19 8 17 -22 9 -39 -21]; What happens if you apply these to a matrix? For example, try applying them to the following matrix:\nrandn(100,5)  Expand for solution Solution The operations yield the following:\n max(x) : 47 min(x) : -70 mean(x) : -7.2333 median(x) : -6.5 mode(x) : -22 std(x) : 27.6314 var(x) : 763.4954 hist(x) :  sort(x) : \u0026gt;\u0026gt; sort(x) ans = Columns 1 through 17 -70 -53 -47 -39 -35 -32 -29 -22 -22 -21 -19 -18 -12 -7 -7 -6 -6 Columns 18 through 30 -5 3 4 8 9 12 12 17 22 28 34 37 47  sum(x) : -217  Applying them to matrices will perform the operation on columns. For example,\nsum(rand(10,5)) will yield a row vector with five elements which are the sums of each column.\nMoreover\nhist(randn(1000,5)) will yield the following multiple histogram with each colour representing a column of the matrix.\n   Question Generate a series of random samples of data of increasing size drawn from (i) a uniform distribution and (ii) a normal distribution. Draw histograms of each sample and, by calculating the mean and standard deviation of each sample, verify that these two statistics tend to their theoretical limit values as the size of the sample increases.\n Expand for hint Hint The mean and variance for a uniform $U(0,1)$ distribution are $\\mu=0.5 \\,,\\, \\sigma=1/\\sqrt{12}$\nThe mean and variance for a normal $N(0,1)$ distribution are $\\mu=0 \\,,\\, \\sigma=1$.\n   Expand for solution Solution To generate the data for 1,000 samples use\nX=rand(1000,1); Y=randn(1000,1); To plot the histograms use\nfigure; hist(X); title(\u0026#39;Data from Uniform\u0026#39;); figure; hist(Y); title(\u0026#39;Data from Normal\u0026#39;); To calculate the mean and standard deviation use\nmean(X) std(X) mean(Y) std(Y) which should be close to the theoretical values of $\\mu=0.5 \\,,\\, \\sigma=1/\\sqrt{12}$ for the $U(0,1)$ data and $\\mu=0 \\,,\\, \\sigma=1$ for the $N(0,1)$ data. These values should get closer as the sample size increases.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/02_vectors_and_matrices/",
	"title": "Vectors and matrices",
	"tags": [],
	"description": "",
	"content": "The following walkthrough exercises contain a number of activities designed to teach you the basics of using MATLAB for working with vectors and matrices.\nBasic vector and matrix manipulation You have already learned many basic matrix manipulation commands in the first unit. This walkthrough provides a quick review of this material with a few new commands added.\nWalkthrough Let\nx=[1,2,3] y=[2,4,6]\u0026#39; z=[2;4;6] Enter the following commands on the command line and make sure you understand what they do. If you are unsure use the MATLAB help files.\nx*y y*x y*z y.*z sum(x) prod(y)  Question Do all of the operations work? If one doesn\u0026rsquo;t then why not.\n Expand for solution Solution y*z will not work as this is multiplying two column vectors together.\n   Now let\nA=[1,2,3;4,5,6;1,3,2] Enter the following commands on the command line and make sure you understand what they do. If you are unsure use the MATLAB help files.\nB=A\u0026#39; A*y A*B det(A) inv(B) B*inv(B) trace(A) A(1,2) A(:,2) A(1,:) A(2,2:3) A([2,1,3],:) A^2 A.^2 sum(A,1) prod(A,2) C=[A,z] ones(5,1) ones(5) zeros(1,5) Now clear the workspace\nclear Size of vectors and matrices You also learned lots of commands for finding the size of vectors and matrices.\nWalkthrough Let\nA=randn(512); b=randn(512,1); Enter the following commands on the command line and make sure you understand what they do. If you are unsure, use the MATLAB help files.\nlength(A) size(A) size(b) b(end) b(end-5:end) Now clear the workspace\nclear Parts of vectors and matrices We often wish to look at certain parts of matrices: the diagonal entries, for example. The following will introduce some commands that will allow you to select specific entries.\nWalkthrough Let\nA= randn(10); Enter the following commands on the command line and use spy to visualise the non-zero entries of the resulting matrices. What do you see?\nMake sure you understand what all the commands do. If you are unsure, use the MATLAB help files.\ntriu(A) tril(A) diag(A) diag(A,2) diag(diag(A)) Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/02_what_is_matlab/",
	"title": "What is MATLAB?",
	"tags": [],
	"description": "",
	"content": "MATLAB is:\n a calculator; a powerful graphics tool; and a high-level programming language including a large number of mathematical tools.  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/03_analytical_methods_2nd_order/",
	"title": "Analytical methods: 2nd order",
	"tags": [],
	"description": "",
	"content": "After dealing with first-order equations, we now look at the simplest type of second-order differential equation, with linear coefficients of the form $$ a\\frac{d^2y}{dx^2} + b\\frac{dy}{dx} + cy = 0 \\,. $$\nTo solve this we look at the solutions to the auxiliary equation, given by $$ ak^2 + bk + c = 0 \\,. $$\nBased on the solutions of the auxiliary equation, the solution takes the following forms:\n  If the solutions are $k=\\alpha,\\beta$ where $\\alpha,\\beta \\in \\Re$, with $\\alpha \\neq \\beta$ then the solutions to the original equation are of the form $y=Ae^{\\alpha x}+Be^{\\beta x}$, where $A,B \\in \\Re$ are constants of integration to be determined by initial or boundary conditions.\n  If the solutions are both $k=\\alpha$ where $\\alpha \\in \\Re$ then the solutions to the original equation are of the form $y=(A+Bx)e^{\\alpha x}$, where $A,B \\in \\Re$ are constants of integration to be determined by initial or boundary conditions.\n  If the solutions are $k=\\pm \\beta i$ where $\\beta \\in \\Re$ then the solutions to the original equation are of the form $y=A\\sin(\\beta x)+B\\cos(\\beta x)$, where $A,B \\in \\Re$ are constants of integration to be determined by initial or boundary conditions.\n  If the solutions are $k=\\alpha\\pm\\beta i$ where $\\alpha,\\beta \\in \\Re$ then the solutions to the original equation are of the form $y=e^{\\alpha x}[A\\sin(\\beta x)+B\\cos(\\beta x)]$, where $A,B \\in \\Re$ are constants of integration to be determined by initial or boundary conditions.\n  Walkthrough We wish to solve $$ \\frac{d^2y}{dx^2}+2\\frac{dy}{dx}+y=0 $$ subject to $$ y(0)=0 \\quad \\textrm{and} \\quad y'(1)=1 \\,.$$ The solutions of the auxiliary equation are both $k=−1$, therefore the general solution is $$ y=(A+Bx)e^{−x} \\,,$$ Applying the boundary conditions $y(0)=0,y'(1)=1$ gives $B=e^1,\\;A=0$, and the solution is therefore $$ y(x)=xe^{1−x} \\,. $$\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/03_eigenvalues_and_eigenvectors/",
	"title": "Eigenvalues and eigenvectors",
	"tags": [],
	"description": "",
	"content": "Key properties of square matrices are their eigenvalues and eigenvectors, which enable them to be written in a simpler form, through a process known as eigenvalue decomposition. This is useful for performing mathematical and numerical analysis of matrices in order to identify their key features. A similar process is available for non-square matrices, known as singular value decomposition (SVD). (Note that SVD also exists for square matrices.) There are inbuilt tools within MATLAB that may be used to perform both of these decompositions.\nInfo For more details on the theory of eigenvalues and singular value decomposition see Linear Algebra and its Applications by Gilbert Strang, or the following web pages:\n http://mathworld.wolfram.com/Eigenvalue.html http://mathworld.wolfram.com/Eigenvector.html http://mathworld.wolfram.com/EigenDecomposition.html http://mathworld.wolfram.com/SingularValueDecomposition.html   We now look at the commands in MATLAB that enable us to calculate these decompositions.\nWalkthrough Consider the square matrix\nA=randn(10); The following commands calculate the eigenvalues and eigenvectors of the matrix (enter the commands):\ne=eig(A); [V,D]=eig(A); Print e, V and D.\nEvaluate the following:\nA*V - V*D  Question What does this give you? Why is this? Use the MATLAB help files to work out what V and D are.\n Expand for solution Solution This gives you a matrix that is zero to machine precision (that is, all their entries are less than $10^{−12}$). This is because the eigenvalue decomposition of $A$ is $A=VDV^{-1}$, where $V$ is a matrix whose columns are the eigenvectors of $A$ and $D$ is a diagonal matrix containing the eigenvalues of $A$.\n   Now consider the non-square matrix:\nA=randn(10,5); The following commands calculate the singular value decomposition (SVD) of the matrix:\n[U,S,V]=svd(A); Evaluate the following\nA - U*S*V\u0026#39;  Question What does this give you? Why is this?\n Expand for solution Solution Again, this gives you a matrix that is zero to machine precision (all entries are less than $10^{−12}$). This is because the singular value decomposition of $A$ is $A=USV^{T}$, where $U$ and $V$ are square orthogonal matrices of different sizes and $S$ is a matrix of the same size as $A$ whose diagonal entries are the singular values of $A$, with extra rows or columns of zeros depending on the size of $A$.\n   Info Note that the command [U,S,V]=svd(A,0) calculates the economic version of the SVD. What is this?\n Expand for solution Solution The economic form just removes the zero rows/columns from $S$.\n   Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/03_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to give you a familiarity with numerical differentiation. Hints and solutions are available.\nQuestion Do the following problem with pen and paper. Using the Taylor series expansion of the form: $$y(t)=y(a)+(t−a)y'(a)+(t−a)^2y''(a)+(t−a)^3\\frac{y'''(a)}{3!}+\\ldots$$\n Derive the forward difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_i}{h}$$ Derive the backward difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_i−y_{i−1}}{h}$$ Derive the central difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_{i−1}}{2h}$$ Optional: If you are feeling adventurous derive the second derivative approximation, $$\\frac{d^2y}{dx^2}\\approx\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2}$$  Hint: you will need to include more terms in your Taylor expansion.\n Expand for solution Solution   Let $t=x_{i+1}$ and $a=x_i$. Then the first two terms of the Taylor expansion give: $$y_{i+1} \\approx y_i+hy'(x_i)$$ Rearranging this gives: $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_i}{h},$$ the forward difference rule.\n  Similarly, using $t=x_{i−1}$ and $a=x_i$ gives, on rearranging: $$\\frac{dy}{dx}\\approx\\frac{y_i−y_{i−1}}{h},$$ the backward difference rule.\n  Adding the two previous formulae together and dividing by 2 gives: $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_{i−1}}{2h},$$ the central difference rule.\n  Finally, if we include the third term in the expansions in 1. and 2. then we get: $$y_{i+1} \\approx y_i+hy'(x_i)+\\frac{h^2}{2}y''(x_i)$$ and $$y_{i−1} \\approx y_i−hy'(x_i)+\\frac{h^2}{2}y''(x_i).$$ Adding these together and rearranging gives: $$\\frac{d^2y}{dx^2}\\approx\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2},$$ the second derivative approximation.\n     Question Let $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced points over the interval $[−3,3]$. Let $h=6/N$, so that $x_{i+1}−x_i=h$. Let $f(x)=x^4$, and so $f'(x)=4x^3$ and $f''(x)=12x^2$.\nBegin by choosing $N=10$:\n Approximate the first derivative at the points $x_0,x_1,x_2,...,x_{N−1}$ using forward differences.   Expand for hint Hint The following code calculates the derivative and produces the following plot:\nN=10; h=6/N; x=linspace(-3,3,N+1); y=x.*x.*x.*x; yprime=4*x.*x.*x; % for i=1:N forwarddiff(i) = (y(i+1)-y(i))/h; end % plot(x,yprime,x(1:N),forwarddiff) legend(\u0026#39;True\u0026#39;,\u0026#39;Forward\u0026#39;)   Approximate the first derivative at the points $x_1,x_2,x_3,\\ldots,x_N$ using backward differences.   Expand for hint Hint Modify the code from part 1.\n   Approximate the first derivative at the points $x_1,x_2,x_3,\\ldots,x_{N−1}$ using central differences.\n  Approximate the second derivative at the points $x_1,x_2,x_3,\\ldots,x_{N−1}$.\n  Plot your approximations and the true values of $f'(x)$ and $f''(x)$ on the same graphs (one for $f'(x)$ and one for $f''(x)$).\n  What is the maximum absolute error for each approximation?\n   Expand for solution Solution The code below will calculate all the approximations and plot them on the same graph as the exact solutions.\nclear all close all N=10; % The number of intervals to use h=6/N; % the step size x=linspace(-3,3,N+1); % %% Calculate the exact solutions y=x.*x.*x.*x; yprime=4*x.*x.*x; yprimeprime=12*x.*x; % %% Calculate the approximations forwarddiff(1) = (y(2)-y(1))/h for i=2:N forwarddiff(i) = (y(i+1)-y(i))/h; backwarddiff(i-1) = (y(i)-y(i-1))/(h); centraldiff(i-1)=(y(i+1)-y(i-1))/(2*h); secondderiv(i-1)=(y(i-1)-2*y(i)+y(i+1))/(h*h); end backwarddiff(N) = (y(N+1)-y(N))/h % %% Evaluate the maximum error for each approximation MaxErrorInForwardDifference=max(abs(yprime(1:N)-forwarddiff)) MaxErrorInBackwardDifference=max(abs(yprime(2:N+1)-backwarddiff)) MaxErrorInCentralDifference=max(abs(yprime(2:N)-centraldiff)) MaxErrorInSecondDerivative=max(abs(yprimeprime(2:N)-secondderiv)) % %% Plot the approximations witht the actual derivatives plot(x,yprime,x(1:N),forwarddiff,x(2:N+1),backwarddiff,x(2:N),centraldiff) title(\u0026#39;First Derivative\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) legend(\u0026#39;True\u0026#39;,\u0026#39;Forward\u0026#39;,\u0026#39;Back\u0026#39;,\u0026#39;Central\u0026#39;) % figure plot(x,yprimeprime,x(2:N),secondderiv) title(\u0026#39;Second Derivative\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) legend(\u0026#39;True\u0026#39;,\u0026#39;Approx\u0026#39;) The maximum error for each approximation is:\n Forward Difference = 28.2960 Backward Difference = 28.2960 Central Difference = 3.4560 Second Derivative = 0.7200  The following plots are generated:    Repeat for $N=20$ and $N=40$.\ni) In each case, how big does $N$ need to be so that the maximum absolute error of the derivative at each discrete point is less than 0.01?\nii) Comment on how the maximum absolute error for each scheme decreases as $N$ is doubled.\n   Expand for solution Solution The maximum errors for different values of $N$ can be calculated by modifying the code from a) above and are given in the table below.\n   N Forward Difference Backward Difference Central Difference Second Derivative     10 28.2960 28.2960 3.4560 0.7200   20 15.1470 15.1470 0.9720 0.1800   40 7.8344 7.8344 0.2565 0.0450    To get a maximum absolute error of less than 0.01 we require:\n $N=323$ for forward and backward differences; $N=208$ for central differences; $N=86$ for the second derivative.  For forward and backward differences, the error roughly halves as $N$ is doubled.\nFor central differences and second derivatives, the error is divided by roughly 4 as $N$ is doubled.\nIn mathematical terms, the first two are \u0026lsquo;first order\u0026rsquo; and the second two are \u0026lsquo;second order\u0026rsquo; as $N$ increases. Don\u0026rsquo;t worry if you don\u0026rsquo;t know what it means.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/03_formatting_code_part_2/",
	"title": "Formatting code: part 2",
	"tags": [],
	"description": "",
	"content": "Comments help to describe the intent of the programmer and document tricky sections of the program. Comments also provide a way of adding metadata, such as physical units. The aim is to describe, rather than duplicate.\nFor example:\n% Initialise voltage to zero voltage = 0.0; just repeats the information in the code, whereas:\n% Transmembrane potential (units - mV) voltage = 0.0; provides more important information.\nWhen writing code, it is good practice to use comments first to lay out a skeleton for the code. This helps to solidify the algorithm in your mind and also means that there is often no need to write more comments afterwards!\nYou can start off with something like\n%% Initialise stiffness matrix % Add boundary conditions %% Assemble linear system % Set initial conditions in Solution vector %% Solve linear system where comments on the main steps are marked %% while those on sub-steps are marked %. This is only one example of using the % to signify parts of your code, and you may wish to use your own, for example\n%%%%%%%%%% %% Main Step %% %%%%%%%%%% %% Sub Step %% Any method you choose is fine as long as you are consistent.\nInfo In MATLAB, a comment starting with a double percent (%%) starts a new \u0026lsquo;section\u0026rsquo; in a script, that is marked by a light yellow background.\nThis can be very useful for structuring code as it is possible to run just a section of your script.\n Creating automatic documentation You can use comments in functions to provide automatic documentation (or help) for your functions.\nWalkthrough For example, if you create an M-file with the following:\nfunction y = average(x) % AVERAGE Mean of vector elements. % Further documentation y = sum(x)/length(x); % Actual computation end Running the command\nhelp average will now produce\n\u0026gt;\u0026gt; help average average Mean of vector elements. Further documentation More help on this functionality can be found here.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/03_getting_matlab/",
	"title": "Getting MATLAB",
	"tags": [],
	"description": "",
	"content": "A pre-requisite for the course is to have the program MATLAB installed on your computer. You will only need the basic version of MATLAB for this course. As you will discover there are many toolboxes are available which extend the functionality of MATLAB but these are not needed for this course. In this section we will get MATLAB set up on your computer.\nChecking for MATLAB If you are using a departmental computer then MATLAB may already have been installed for you. The following will show you if it is installed or not.\nIf you have the following icon on your desktop (or in your start menu) then you already have MATLAB installed: In Linux, try typing matlab into the command line to see if you have MATLAB installed. If it is installed then the MATLAB Command window will open.\nIf MATLAB is installed on your computer then you can ignore the rest of this section. However, if you don\u0026rsquo;t have MATLAB installed on your machine then contact your College or Department\u0026rsquo;s IT support officers and they will be able to help.\nIf you are using a personal computer for this course then there are a few ways of getting MATLAB.\nDownloading MATLAB from inside Oxford University If you are an Oxford University student then MATLAB is available from IT Services under a university-wide student licence, details of which can be found at the following link:\nhttps://help.it.ox.ac.uk/sls/matlab\nYou will need to use your Single Sign-On to get access to MATLAB.\nUsing MATLAB online It is possible to use MATLAB in your web browser by going to:\nhttps://matlab.mathworks.com/\nThis still requires you to have an account with MathWorks, which you can obtain via the University of Oxford by following the instructions above. While using MATLAB in the browser may be sufficient for this course, it is preferable to have MATLAB installed on the machine you will be using. You will get better performance, have access to more features, have have your files stored locally.\nPurchasing MATLAB directly from MathWorks If you don\u0026rsquo;t have an Oxford University Single Sign-On, and your IT support cannot setup MATLAB for you, then you can also purchase MATLAB directly from MathWorks, at https://www.mathworks.com/.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/03_linear_regression/",
	"title": "Linear regression",
	"tags": [],
	"description": "",
	"content": "When presented with a data-set, one way to analyse the data is to perform linear regression. The most common form of linear regression is known as ‘least squares fitting’, whose aim is to fit a polynomial curve to the data such that the sum of the squares of the distance from the data points to the line is minimised.\nInfo If you have never come across this before then look it up. The first link has a particularly good description.\nThe theory of least squares fitting can be found in the following:\n Wolfram MathWorld Chapter 7 of The Statistical Sleuth by Ramsey and Schafer. Chapter 24 and 25 (in the tenth edition) of Advanced Engineering Mathematics by Erwin Kreyszig.   The following activity will lead you through generating some experimental data adding artificial noise and then performing least squares estimation to try to elucidate the underlying model parameters.\nQuestion Often mathematical models of experimental or physiological systems are developed to form the basis of a measurement technique. For example, it is not possible to measure cardiac output directly, but we may be able to infer it from analysis of a mathematical model of respiratory gas exchange. For such models we are often solving an inverse problem of parameter estimation (the cardiac output), where the parameter of interest is embedded (somewhere) within the mathematical model. In these circumstances, it is often advisable to introduce simulated experimental error into the system to test the robustness of the recovery procedure. The following is one of the simplest possible examples, where the parameters form part of a linear model, but more commonly the parameters would be embedded within a system of ODEs or PDEs or in some complex stochastic process.\n Generate and plot the data ($x$ and $y$ values) for a simple straight line of the form $y=ax+b$ where $a=2$ and $b=1$ are constants and $x\\in\\left[0,1\\right]$. You should calculate the value of $y$ at 21 evenly spaced points between 0 and 1, (that is, at $x=0,0.05,0.1,\\ldots,1$).   Expand for solution Solution The following will generate and plot the line.\n% Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); plot(x,y,\u0026#39;b.-\u0026#39;) which yields the following figure.\n  Generate random errors from a normal distribution, with zero mean $\\mu$ and standard deviation $\\sigma=0.1$, using MATLAB’s inbuilt commands, and add these to each of the $y$ coordinates in 1. Plot these values as points on the same graph as in 1. What happens if $\\mu$ is non-zero?   Expand for solution Solution The following will generate noise, add it to the line and plot it with red crosses.\n% Simulate random noise around this line noise=randn(size(y)); % Generating numbers from a N(0,1) dist stdnoise=0.1; % Standard deviation of the noise ynoisy=y+stdnoise*noise; % Make the noisy data hold on; % note this puts the plots on the same figure plot(x,ynoisy,\u0026#39;rx\u0026#39;) which yields the following figure.\nNote: your noise will be different, so the red crosses may be in slightly different places, but they will still be close to the original line.\n  Using the command polyfit perform a linear regression through the data generated in 2, and plot the regression line on the same plot.   Expand for solution Solution The command\np=polyfit(x,ynoisy,1); will calculate the coefficients of the regression line $y=\\alpha{x}+\\beta$ (to the line $y=ax+b$), where the coefficients are in descending order, so the constant term is the second entry. This is a general function, and the third variable specifies the order of the regression line. For example:\np=polyfit(x,ynoisy,2); would calculate the quadratic regression coefficients.\nTherefore, the following code will calculate the regression line and plot it on the same figure in red.\np=polyfit(x,ynoisy,1); z=p(1)*x + p(2); plot(x,z,\u0026#39;r\u0026#39;); which yields the following figure.\n  Repeat 2 and 3 for differing values of the standard deviation, from $\\sigma=0$, to $\\sigma=1$, in steps of 0.2, and plot the regression lines on the same graph. You should use a loop to do this.   Expand for solution Solution The following code will generate and plot these lines.\nclear close all % Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); % i=1; for stdnoise=0:0.2:1 % Generate N(0,1) random errors and add to the data with % a suitably scaled standard deviation noise=randn(size(y)); ynoisy(:,i)=y+stdnoise*noise; % Fit a straight line through the noisy data using Polyfit p(:,i)=polyfit(x,ynoisy(:,i),1); z(:,i)=p(1,i)*x+p(2,i); i=i+1; end % plot(x,z); legend(\u0026#39;0.0\u0026#39;,\u0026#39;0.2\u0026#39;,\u0026#39;0.4\u0026#39;,\u0026#39;0.6\u0026#39;,\u0026#39;0.8\u0026#39;,\u0026#39;1.0\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;); hold on plot(x,ynoisy,\u0026#39;.\u0026#39;); This yields the following figure.\n  For a suitable value of the standard deviation ($\\sigma=0.1$), repeat 2 and 3 1,000 times to investigate the statistical properties of the regression coefficients. To do this you should calculate the mean and standard deviation of the regression coefficients and compare them to the theoretical values of $\\mu=1 \\,,\\, \\sigma\\approx0.042$ for $a$, and $\\mu=2 \\,,\\, \\sigma\\approx0.071$ for $b$. The estimators should also be normally distributed. You do not need to know how these were calculated, but note that the estimators are unbiased, as the mean values of the estimators of the parameters are the parameters themselves.   Expand for solution Solution The following code will generate the means and standard deviations of the regression coefficients for 1,000 sets of random noise.\nclear close all % Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); % % Calculate the Regression Coefficients for 1000 sets of noise. n=1000; for i=1:n % Generate N(0,1) random errors and add to the data with % a suitably scaled standard deviation noise(:,i)=randn(size(y)); stdnoise=0.1; ynoisy(:,i)=y+stdnoise*noise(:,i); % Fit a straight line through the noisy data using Polyfit p(:,i)=polyfit(x,ynoisy(:,i),1); end % % Look at the distributions of a and b b=p(1,:); % The first row of the matrix p a=p(2,:); % The second row of the matrix p % abar=mean(a) % Calculates the mean bbar=mean(b) % sda=std(a) % Calculates the standard deviation sdb=std(b) % % Plot Histograms of the coefficients figure(1) hist(a,30) figure(2) hist(b,30) The regression coefficients for $a$ have the following distribution\nWith mean $\\mu\\approx1$ and variance $\\sigma\\approx0.04$\nThe regression coefficients for $b$ have the following distribution\nWith mean $\\mu\\approx2$ and variance $sigma\\approx0.07$\n  Explain why the above can be used to simulate the effects of random experimental error.   Expand for solution Solution Experimental error will manifest as noise added to the results, so we can apply this method to hope to reveal the underlying model parameters.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/03_starting_matlab/",
	"title": "Starting MATLAB",
	"tags": [],
	"description": "",
	"content": "Windows  Expand for Windows instructions  In the File Explorer, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. To start MATLAB click on the \u0026lsquo;MATLAB\u0026rsquo; icon, and change the \u0026lsquo;Current Directory\u0026rsquo; to the one you just created. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   macOS  Expand for macOS instructions  In Finder, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. To start MATLAB click on the \u0026lsquo;MATLAB\u0026rsquo; icon, and change the \u0026lsquo;Current Directory\u0026rsquo; to the one you just created. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   Linux  Expand for Linux instructions   Open a terminal and type\nmkdir MatlabCourse cd MatlabCourse to make a directory and switch to it.\n  From within the directory you just created, type\nmatlab \u0026amp; A MATLAB window should now open. Any files created and saved will now be saved within this directory. Note that the \u0026lsquo;\u0026amp;\u0026rsquo; will free the MATLAB window from the terminal; otherwise, if you close the terminal you close MATLAB.\n  You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;. Note that you can use the mkdir command from within the MATLAB command window.\n   Online  Expand for web browser instructions  Go to https://matlab.mathworks.com/. Log in with your MathWorks account. In the \u0026lsquo;Current Folder\u0026rsquo; panel, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. Double-click to enter that folder, which will set it as the current working directory. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/04_basic_data_and_image_processing/",
	"title": "Basic data and image processing",
	"tags": [],
	"description": "",
	"content": "MATLAB has many powerful tools to read in files and manipulate data, and we will use this functionality here to read in some data and image files to undertake some basic processing.\nThere are many MATLAB commands that are used to read in data from files and write data to files, for example\n load save imread imwrite  Info Before you continue, take a look at the help files for these commands.\n Loading and saving data files In the following example we will load in data from one file and write out the data to a different file.\nWalkthrough Download the Data1.txt to the current working directory.\nTo load in data from the file \u0026lsquo;Data1.txt\u0026rsquo; we use the load command\nload Data1.txt which creates the variable Data1.txt which is a $10000\\times1$ vector (seen by using the whos command).\nAlternatively, you could load the file by using the following\ndata = load(\u0026#39;Data1.txt\u0026#39;); which allows you to specify the variable name. If you want to load a file in a different directory, then you need to use the second command as you can pass the file location as a string. If, for example, you were storing your data in a different directory (in the current working directory) called \u0026lsquo;Data\u0026rsquo;, you could use the command\ndata = load(\u0026#39;Data/Data1.txt\u0026#39;); To save data to a file you use the save command, which works in a similar way. The following command will save the variable data as a file \u0026lsquo;TestSave.txt\u0026rsquo; in plain text as specified by the –ascii option.\nsave \u0026#39;TestSave.txt\u0026#39; data -ascii Loading and saving the whole workspace You can also use save and load to save all the variables in your workspace as a .mat file. Note that this file can only be read by MATLAB, unlike the .txt files we made in the previous example.\nWalkthrough We begin with an empty workspace\nclear and define some variables\nx=rand(10); y=rand(10,1); whos To save all these variables we use the command\nsave AllVariables.mat; Now if we clear all the variables\nclear; whos you can see the workspace is now empty. The command\nload AllVariables.mat; will load back all the saved variables, as can be seen by typing\nwhos You can also load image files using the \u0026lsquo;imread\u0026rsquo; command as shown in the following example.\nLoading and saving images Walkthrough Download the file TestImage.png to the current working directory.\nThis is the image you are saving:\nThe following command will load the image into MATLAB and store it as a matrix in which each entry is a number between 0 and 255 that represents the intensity of that pixel. Note that this is a black-and-white image so there is only one intensity value for each pixel. If the image were in colour then there would be three such matrices (one for each base colour).\nA=imread(\u0026#39;TestImage.png\u0026#39;); You can view the image in MATLAB by typing the command\nimage(A) Suppose we had made some modifications to the image, for example by cropping the image\nA(:,[1:13, 107:end])=[]; image(A); The matrix A could be saved as an image by using the command\nimwrite(A,\u0026#39;TestCroppedImage.png\u0026#39;); which produces a file \u0026lsquo;TestCroppedImage.png\u0026rsquo; which looks like the following figure\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/04_formatting_code_part_3/",
	"title": "Formatting code: part 3",
	"tags": [],
	"description": "",
	"content": "Whitespace Whitespace is generally not significant to the computer, but it makes a big difference to code\u0026rsquo;s readability to humans. Take a look at the following examples.\nCan(you, tell, at + a, glance, which * of, these, parameters, is(the, eighth), one); This(is, ... much, ... nicer); This=is+almost*(as-annoying); This = is + much * (more - readable); Nested functions You can define functions inside other functions – known as \u0026lsquo;nested\u0026rsquo; functions – which can improve the readability of the code and save you from having to use multiple files. In the following example of nested functions, note how indentation helps to distinguish functions from each other. (This can be done automatically within the MATLAB editor by using the smart indent command in the \u0026lsquo;Text\u0026rsquo; menu or the \u0026lsquo;Ctrl-I\u0026rsquo; command in Windows.)\nfunction A(x, y) % Primary function B(x, y); D(y); function B(x, y) % Nested in A C(x); D(y); function C(x) % Nested in B D(x); end end function D(x) % Nested in A z = x + y; end end Look up nested functions in the MATLAB help system.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/04_numerical_integration/",
	"title": "Numerical integration",
	"tags": [],
	"description": "",
	"content": "You should already be familiar with analytic integration, as both the inverse of differentiation and a means of finding the area under a curve. If you are unsure about this, look it up now in any A level textbook or the relevant section of the Calculus Wikibook.\nFor most functions that you will come across in mathematical modelling, it will not be possible to undertake the integration analytically, and you will have to resort to numerical methods. The following explains two numerical methods for approximating integrals: the Trapezium rule, and Simpson\u0026rsquo;s rule.\nSummary of mathematics used Suppose $y=f(x)$. Let the points $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced points on the interval $[a,b]$, and let $h=\\frac{1}{N}(x_N−x_0)=x_{i+1}−x_i$. Now let $y_i=f(x_i)$. The Trapezium rule for approximating integrals is:\n$$\\int_a^b f(x) \\,dx \\approx h\\left( \\frac{1}{2}y_0+y_1+y_2+\\ldots+y_{N-1}+\\frac{1}{2}y_N \\right).$$\nThis is equivalent to breaking up the area under the curve into a series of trapezia and calculating their areas, as shown in the following figure, where $y_i=f(x_i)$. The figure is from Wikipedia, unmodified, shared under the CC BY-SA 3.0 license.\nAssuming that $N$ is even, Simpson\u0026rsquo;s rule for approximating integrals is\n$$\\int_a^b f(x) \\,dx \\approx \\frac{h}{3}\\left( y_0 + 4\\left( y_1+y_3+\\ldots+y_{N-1} \\right) + 2\\left( y_2+y_4+\\ldots+y_{N-2}\\right) + y_N\\right). $$\nThis is derived in a similar way to the Trapezium rule, but by approximating the function by a quadratic curve on each interval, rather than the linear curve used by the Trapezium rule.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/04_reducing_higher_order_odes/",
	"title": "Reducing higher order ODEs",
	"tags": [],
	"description": "",
	"content": "If we have a general second-order equation of the form $$ a(x)\\frac{d^2y}{dx^2} + b(x)\\frac{dy}{dx} + c(x)y = f(x), $$ we can reformulate this as a system of first-order equations. If we let $z=\\frac{dy}{dx}$, then the above equation can be written as $$ \\frac{dy}{dx} = z \\,,$$ $$ \\frac{dz}{dx} = \\frac{f(x) − b(x)z−c(x)y}{a(x)} \\,, $$ which is a system of first-order equations.\nTherefore we can reduce any second-order ODE to a system of first-order ODEs. Furthermore, using this approach we can reduce any higher-order ODE to a system of first-order ODEs. For example, a fourth-order ODE would yield a system of four first-order ODEs.\nTherefore we only need to consider numerical techniques for solving first-order systems of ODEs, since any higher-order equation can simply be reduced to a system of first-order equations.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/04_sparse_matrices/",
	"title": "Sparse matrices",
	"tags": [],
	"description": "",
	"content": "The numerical solution of differential equations often results in what is known as a \u0026lsquo;sparse linear\u0026rsquo; system. A matrix is \u0026lsquo;sparse\u0026rsquo; if most of its entries are zero, and most of the MATLAB functions you have used so far have versions that are specially optimised for sparse matrices, which can speed up your code immensely. The details of this speeding-up will be discussed further in the later unit \u0026lsquo;Software engineering\u0026rsquo;, but we introduce sparse matrices here as they will be used in exercises later in this unit.\nThe following will give you an introduction to the uses of sparse matrices.\nWalkthrough Create the matrix A using the following commands:\nA=2*eye(5000)-diag(ones(4999,1),1)-diag(ones(4999,1),-1); Run the following commands to investigate the structure of A:\nA(1:5,1:5) nnz(A) spy(A) spy(A(1:10,1:10))  Question What is the structure of A?\n Expand for solution Solution A is \u0026lsquo;tri-diagonal\u0026rsquo;, with 2 on the diagonal and −1 on the adjacent diagonals. Therefore, A has $5000+(2\\times 4999)=14998$ non-zero entries, as found using nnz(A).\n   Calculate the inverse of A.\nNote The inverse of A is not sparse. This is true in general.\n Ai=inv(A); spy(abs(Ai)\u0026gt;1) spy(abs(Ai)\u0026gt;5) spy(abs(Ai)\u0026gt;10) spy(abs(Ai)\u0026gt;100) Calculate how long it takes to calculate $A^2$.\nInfo You can use the commands tic and toc to record elapsed time in MATLAB.\n tic; A*A; toc Create the matrix B using the following commands. Note that A and B have the same non-zero entries:\nB=spdiags(ones(5000,1)*[-1,2,-1],[-1,0,1],5000,5000); The command spdiags creates a sparse matrix with the entries from the vector (passed as the first variable) on the diagonal indicated by the second variable. These variables can be passed individually or in groups as in the above example. The final two variables represent the size of the matrix. Look at the MATLAB help files for more information on spdiags.\nLook at the structure of B:\nB(1:5,1:5) full(B(1:5,1:5)) nnz(B)  Question Using the command whos, look at how the matrices A and B are stored. Which uses less memory?\n Expand for solution Solution \u0026gt;\u0026gt; whos A Name Size Bytes Class Attributes A 5000x5000 200000000 double \u0026gt;\u0026gt; whos B Name Size Bytes Class Attributes B 5000x5000 279976 double sparse So A used 2000000 bytes, and B only used 27976 bytes, saving about 98.6% of the space.\n   Question Calculate how long it takes to calculate $B^2$:\ntic; B*B; toc Which is quicker, $A^2$ or $B^2$?\n Expand for solution Solution \u0026gt;\u0026gt; tic; A*A; toc Elapsed time is 0.768850 seconds. \u0026gt;\u0026gt; tic; B*B; toc Elapsed time is 0.013921 seconds. Calculating $B^2$ should be faster, and the proportion that it is faster should increase with the size of the matrix.\n   Question Now compare the \\ operator\nb=ones(5000,1); tic; x1=A\\b; toc tic; x2=B\\b; toc Which is quicker, A\\b or B\\b?\n Expand for solution Solution \u0026gt;\u0026gt; b=ones(5000,1); tic; x1=A\\b; toc tic; x2=B\\b; toc Elapsed time is 0.268863 seconds. Elapsed time is 0.000719 seconds. Calculating B\\b should be faster, and the proportion that it is faster should increase with the size of the matrix.\n   Finally, you can also convert matrices from full to sparse using the following command\nA=sparse(A); Using the command whos, check that A is now sparse and uses the same memory as B.\nNow clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/04_using_matlab_as_a_calculator/",
	"title": "Using MATLAB as a calculator",
	"tags": [],
	"description": "",
	"content": "The first thing we will use MATLAB for is a calculator.\nMATLAB uses the standard computer symbols for addition ('+'), subtraction ('-'), multiplication ('*') and division ('/'). Brackets are also used (if required) to indicate which operations are to be performed first.\nFor example, to evaluate $3 + 4\\left(1 + \\frac{6}{3}\\right)$ type the following in the Command Window:\n3+4*(1+6/3) and you get the answer 15. Your Command Window should look just like:\n\u0026gt;\u0026gt; 3+4*(1+6/3) ans = 15 Suppose we wished to set the variable x equal to $3 + 4\\left(1 + \\frac{6}{3}\\right)$. Then we would type\nx=3+4*(1+6/3) and get the answer x = 15. In long calculations it is often unnecessary for the value of x to be output to the screen. If we wanted to calculate x but not output the answer to the screen we would end the line with a semicolon\nx=3+4*(1+6/3); The value of x may now, if desired, be printed out by typing\nx To evaluate a power we use the \u0026lsquo;^\u0026rsquo; symbol. For example, to evaluate $3^4$ type\n3^4 Finally, you can clear the variable x by typing\nclear Now typing\nx shows that the variable x has been deleted:\n\u0026gt;\u0026gt; x Unrecognized function or variable \u0026#39;x\u0026#39;. "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/05_exercises/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "This unit closes with a few simple exercises for you to test the skills you have learned.\nQuestion   Download the files Data1.txt and Data2.txt to the current working directory and load them into MATLAB.\n  Using the statistical tools you learned earlier, try to identify what the data could be from.\n   Expand for hint Hint Plot a histogram of the two data-sets and calculate their means and standard deviations. You should be able to recognise an underlying probability distribution.\n   Expand for solution Solution You can load the files with the command\ndataset1 = load(\u0026#39;Data1.txt\u0026#39;); dataset2 = load(\u0026#39;Data2.txt\u0026#39;); and you can plot the histograms of both datasets using\nsubplot(1,2,1); hist(dataset1); title(\u0026#39;Data1\u0026#39;); subplot(1,2,2); hist(dataset2); title(\u0026#39;Data2\u0026#39;); which yields the plots below.\nIt is clear that the first data-set is from a normal distribution and the mean and standard deviation are found by using\nmean(dataset1) std(dataset1) mean = 175.3321 and std=10.0953\nFor the second data-set it is not clear what the distribution is, as there is a relatively low number of data points, but it is still drawn from a normal distribution, whose mean and standard deviation are\nmean = 192.0019 and std = 5.2121\nThe data are simulated height data. The first dataset represents heights of 10,000 men in the UK population, while the second represents the heights of 50 Olympic rowers, so the average height is larger in the second group than in the normal population.\nCode which brings all this together is given below.\nclear; close all; % dataset1 = load(\u0026#39;Data1.txt\u0026#39;); dataset2 = load(\u0026#39;Data2.txt\u0026#39;); % % plot the data as histograms subplot(1,2,1); hist(dataset1); title(\u0026#39;Data1\u0026#39;); subplot(1,2,2); hist(dataset2); title(\u0026#39;Data2\u0026#39;); % % calculate the mean and standard deviation of the data mean(dataset1) std(dataset1) mean(dataset2) std(dataset2)     Question   Download the image file TestImage.png to the current working directory and load it into MATLAB.\n  Perform \u0026lsquo;thresholding\u0026rsquo; on the image to remove the noise within it. Thresholding is an image analysis technique designed to remove noise from image to pick out its features, in this case by adjusting the intensity to 255 for any pixel in which it is already over 125, and to 0 for any pixel in which it is already below 125.\n  Save the resulting image to file.\n   Expand for hint Hint Use imread and imwrite to load and save the image.\nOnce the image is loaded in, you can treat it like a traditional matrix so you can perform operations such as\nfind(A\u0026gt;125) which will give you all the entries of A that are greater than 125, and use this to set them all to 255.\n   Expand for solution Solution Code that loads the image and performs the thresholding is given below.\nclear; close all; % % Load image TestImage = imread(\u0026#39;TestImage.png\u0026#39;); % % Threshold image as instructed in question TestImage(TestImage \u0026gt; 125) = 255; TestImage(TestImage \u0026lt; 125) = 0; % % Save thresholded image imwrite(TestImage,\u0026#39;ThresholdedImage.png\u0026#39;); The original image is given first and the thresholded image is below, as you can see the noise is removed.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/05_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": "The following exercise will allow you to practise what you have learned so far in this unit.\nLet $A$ be a sparse symmetric positive definite matrix of dimension $(N-1)^2\\times (N-1)^2$ entered in MATLAB (for a given $N$) by the function buildA as follows:\nfunction A=buildA(N) dx=1/N; nvar=(N-1)^2; e1= ones(nvar,1); e2=e1; e2( 1:N-1:nvar)=0; e3=e1; e3(N-1:N-1:nvar)=0; A=spdiags([-e1 4*e1 -e1],-(N-1):N-1:N-1,nvar,nvar)... +spdiags([-e3 -e2], -1: 2 : 1,nvar,nvar); A=A/dx^2; end We will consider manipulation of the matrix $A$, which will be used again in later exercises as the solution to the linear system containing this $A$. This corresponds to a finite difference solution to Poisson\u0026rsquo;s equation:\n$$-\\nabla^2u=f$$\non the unit square with zero Dirichlet boundary conditions.\nQuestion   Copy the function buildA above into a new file buildA.m in your current working directory.\n  Set $N=4$ and produce a spy plot of the matrix $A$. How many non-zero diagonals are there? How many non-zero entries are there?\n  What is the determinant of $A$ when $N=4$?\n  When $N=4$, which entries of $A^{-1}$ are greater than 0.02?\n  For $N=4$, check that $A$ is symmetric by producing a spy plot of $A-A^T$: if $A$ is symmetric there should be no non-zero entries. Check that $A$ is positive definite by looking at its eigenvalues: they should all be strictly positive.\n   Expand for solution Solution  To create the spy plot of the matrix $A$, use the MATLAB function spy(A). From this we see that there are five non-zero diagonals. Using nnz(A) we see that there are 33 non-zero entries.   When $N=4$, the MATLAB command det(A) gives the determinant as 6.8961e+15.\n  Letting B=inv(A), the command [i,j]=find(B\u0026gt;0.02) tells us that the entries (2,2), (4,4), (5,5), (6,6) and (8,8) are greater than 0.02.\n  The spy plot spy(A-A') shows no non-zero entries. Likewise, A-A' yields All zero sparse: 9×9. Both tell us that $A$ is symmetric.\nThe command e=eigs(A,9) tells us the eigenvalues are:\n\u0026gt;\u0026gt; e=eigs(A,9) e = 109.2548 86.6274 86.6274 64.0000 64.0000 64.0000 41.3726 41.3726 18.7452 and, hence, are all strictly greater than zero.\n  Note Here, by default, eigs(A) only gives a subset of the eigenvalues, but we can force MATLAB to calculate all eigenvalues by specifying the number that we want: hence, eigs(A,9).\nAn $N\\times N$ matrix will always have $N$ eigenvalues, although some may be repeated, as is the case here.\n    "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/05_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": "Before we move on to the next section, make sure you can solve the following problems analytically using pen and paper. Hints and solutions are available.\nQuestion Solve $\\frac{dy}{dx} = x^2$ subject to $y(0) = 1$.\n Expand for hint Hint Try just integrating the right-hand side.\n   Expand for solution Solution Integrating both sides yields $$ y = \\int x^2\\,dx + C \\,. $$ This is the general solution to the differential equation, to which we now need to apply the initial condition $y(0)=1$.\n$ 1 = y(0) = C$, so we take $C=1$. The solution is therefore $$ y = \\frac{x^3}{3} + 1 \\,. $$\n   Question Solve $\\frac{dy}{dx} = \\frac{x^2}{y}$, suvject to $y(0) = 1$.\n Expand for hint Hint Try separation of variables.\n   Expand for solution Solution Separation of variables yields $$ \\int y\\,dy = \\int x^2\\,dx + C \\,. $$ Therefore $$ \\frac{y^2}{2} = \\frac{x^3}{3} + C\\,. $$ On rearranging we get $$ y = \\pm \\sqrt{2\\left(\\frac{x^3}{3} + C\\right)} $$ This is the general solution to the differential equation, to which we now need to apply the initial condition $y(0)=1$.\n$1=y(0) = \\pm \\sqrt{0+C}$, so we take the positive root and $C=1$. The solution is therefore\n$$ y = \\sqrt{\\frac{2x^3}{3} + 1} \\,.$$\n   Question Solve $\\frac{dy}{dx} + \\frac{2y}{x} = x^4$ subject to $y(1) = 1$.\n Expand for hint Hint Try using an integrating factor.\n   Expand for solution Solution The integrating factor is $$ \\varphi = e^{\\int \\frac{2}{x}\\,dx} = x^2 \\,. $$ The general solution to the equation is therefore $$ y = \\frac{x^5}{7} + \\frac{C}{x^2} \\,. $$ Applying the initial condition gives $$ 1 = y(1) = \\frac{1}{7} + C \\,, $$ so $C = \\frac{6}{7} $. The solution is therefore $$ y = \\frac{x^5}{7} + \\frac{6}{7x^2} \\,.$$\n   Question Solve $\\frac{dy_1}{dx} = -y_2$ and $\\frac{dy_2}{dx} = y_1$, subject to $y_1(0) = 1$ and $y_2(0) = 0$.\n Expand for hint Hint Combining these two equations, by differentiating the first and substituting it in the second, yields a second-order ODE with linear coefficients. Look at the characteristic equation.\n   Expand for solution Solution Combining these two equations (differentiating the first and substituting it into the second) gives $$ \\frac{d^2y_1}{dx^2}=−y_1 \\,. $$ The general solution to this is $$ y_1=A\\cos(x)+B\\sin(x) \\,. $$ From the first equation we can calculate $y_2$ as $$ y_2=A\\sin(x) − B\\cos(x)\\,.$$ Applying the initial conditions gives $A=1$ and $B=0$. The solution is therefore $$ y_1=\\cos(x) \\quad \\textrm{and} \\quad y_2=\\sin(x). $$\n   Question Solve $\\frac{d^2y}{dx^2} + 3\\frac{dy}{dx} - 4y = 0$, subject to $y(0)=1$ and $y'(0) = 0$.\n Expand for hint Hint This is a second-order ODE with linear coefficients. Look at the characteristic equation.\n   Expand for solution Solution The general solution to this is $$ y=Ae^x+Be^{−4x} \\,. $$ Applying the initial conditions gives $A=\\frac{4}{5}$ and $B=\\frac{1}{5}$. The solution is therefore $$ y=\\frac{4}{5}e^x+\\frac{1}{5}e^{−4x} \\,.$$\n   Close of section There are many methods for solving ODEs analytically, but we may not be able to calculate explicit forms for the integrals, even if we can formulate a given ODE into one of the known forms. Furthermore, if we wish to solve an equation that does match one of the standard forms, then we must recourse to numerical methods. This is the case for most systems of ODEs that represent real-world situations, since most of these are highly non-linear.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/05_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to give you familiarity with numerical integration. Hints and solutions are available.\nQuestion Evaluate $\\int_{-1}^{1} x^4 \\,dx$ using:\n  the Trapezium rule with 10 equal-sized intervals,\n  Simpson’s rule with 10 equal-sized intervals.\n  In each case, how many uniformly sized intervals do you need for the absolute error in the answer to be less than 0.0001?\n Expand for solution Solution The following code calculates the Trapezium rule and Simpson’s rule approximations for $N=10$.\nclear all % N=10; % Number of intervals h=2/N; % The size of each interval x=linspace(-1,1,N+1); y=x.*x.*x.*x; % Defining the function % % Firstly we apply the Trapezium rule: % TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:N TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(N+1); TrapeziumIntegral=TrapeziumIntegral*h % % Now we apply Simpson’s rule: % SimpsonIntegral=y(1); % Initialise % for i=1:N/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:N/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(N+1); SimpsonIntegral=SimpsonIntegral*h/3 The true answer is $\\left[ \\frac{x^5}{5} \\right]_{-1}^{1} = 0.4.$\nTo get the answer within 0.0001 of the true value, we require $N=164$ for the Trapezium rule and $N=16$ for Simpson’s rule. MATLAB code to calculate the $N$ required to get the integral to the required accuracy is given below:\nclear all format long % % Now look for required N for Trapezium rule % TargetError=0.0001; TrapeziumError=1; % initialise error Ntrap=10; % initial Ntrap ExactIntegral = 0.4; % while (TrapeziumError\u0026gt;TargetError) Ntrap=Ntrap+1; % Number of intervals h=2/Ntrap; % The size of each interval x=linspace(-1,1,Ntrap+1); y=x.*x.*x.*x; % Defining the function % % Now we apply the Trapezium rule: TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:Ntrap TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(Ntrap+1); TrapeziumIntegral=TrapeziumIntegral*h; % TrapeziumError = abs(TrapeziumIntegral-ExactIntegral); end % Ntrap TrapeziumError % % Now look for required N for Simpson’s rule % TargetError=0.0001; SimpsonError=1; % initialise error Nsimp=10; % initial Nsimp ExactIntegral = 0.4; % while (SimpsonError\u0026gt;TargetError) Nsimp=Nsimp+2; % Number of intervals so even h=2/Nsimp; % The size of each interval x=linspace(-1,1,Nsimp+1); y=x.*x.*x.*x; % Defining the function % % Now we apply Simpson’s rule: SimpsonIntegral=y(1); % Initialise % for i=1:Nsimp/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:Nsimp/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(Nsimp+1); SimpsonIntegral=SimpsonIntegral*h/3; % SimpsonError = abs(SimpsonIntegral-ExactIntegral); end % Nsimp SimpsonError     Question   Repeat the previous question for $\\int_0^1 \\left( e^{-1000x}+x \\right) \\,dx.$\n  Can you suggest a more sensible way to choose the discrete points instead of using uniformly spaced points?\n   Expand for solution Solution  The true answer is $\\left[ \\frac{-e^{-1000x}}{1000} + \\frac{x^2}{2}\\right]_0^1 = \\frac{1-e^{-1000}}{1000} + \\frac{1}{2} \\approx 0.501.$  To get an answer within 0.0001 of true value, we require $N=904$ for the Trapezium rule and $N=426$ for Simpson’s rule. The MATLAB code for Problem 3 can be modified for this question and is given below.\nclear all format long % Now look for required N for Trapezium rule % TargetError=0.0001; TrapeziumError=1; % initialise error Ntrap=10; % initial Ntrap ExactIntegral = (1-exp(-1000))/1000+0.5; % while (TrapeziumError\u0026gt;TargetError) Ntrap=Ntrap+1; % Number of intervals h=1/Ntrap; % The size of each interval x=linspace(0,1,Ntrap+1); y=exp(-1000*x)+x; % Defining the function % % Now we apply the Trapezium rule: TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:Ntrap TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(Ntrap+1); TrapeziumIntegral=TrapeziumIntegral*h; % TrapeziumError = abs(TrapeziumIntegral-ExactIntegral); end % Ntrap TrapeziumError % % Now look for required N for Simpson’s rule % TargetError=0.0001; SimpsonError=1; % initialise error Nsimp=10; % initial Nsimp ExactIntegral = (1-exp(-1000))/1000+0.5; % while (SimpsonError\u0026gt;TargetError) Nsimp=Nsimp+2; % Number of intervals so even h=1/Nsimp; % The size of each interval x=linspace(0,1,Nsimp+1); y=exp(-1000*x)+x; % Defining the function % % Now we apply Simpson’s rule: SimpsonIntegral=y(1); % Initialise % for i=1:Nsimp/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:Nsimp/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(Nsimp+1); SimpsonIntegral=SimpsonIntegral*h/3; % SimpsonError = abs(SimpsonIntegral-ExactIntegral); end % Nsimp SimpsonError In order to improve accuracy, a non-uniform distribution of the $x_i$, with a higher density close to the origin, could be used.     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/05_guis_part_1/",
	"title": "GUIs: part 1",
	"tags": [],
	"description": "",
	"content": "If you are developing code for other people to use, then it is much better to provide the user with an interface rather than having to type commands into MATLAB. Moreover, developing a user interface will also make the code more usable for you and make it easier for you to demonstrate your code to other people.\nMATLAB has inbuilt functionality that enables you to create GUIs with a few simple commands. The following example will teach you all the basics you need to create a simple GUI, and you will use this to make your own GUI in the later exercises.\nSetup of example GUI In this example we will construct a simple GUI which plots the function $y=\\sin(kx)$ for different values of $k$ using a slider to vary the value of the parameter $k$.\nThe code to create a GUI consists of three parts:\n the figure, which holds the GUI, the controls using uicontrol, and the plot function, which does the solving and/or plotting.  Setting up the figure First we make a large figure to contain the GUI\nfigure(\u0026#39;position\u0026#39;,[0 0 700 500], \u0026#39;name\u0026#39;,\u0026#39;SimpleGUI\u0026#39;,\u0026#39;NumberTitle\u0026#39;,\u0026#39;off\u0026#39;); The variables passed to \u0026lsquo;figure\u0026rsquo; dictate the properties of the figure:\n The pair 'position',[0 0 700 500] specifies the xy-position of the figure (the first two elements of the vector) in pixels from the bottom-left of your screen, and the width and height of the figure (the last two elements) in pixels. The pair \u0026lsquo;name\u0026rsquo;, \u0026lsquo;SimpleGUI\u0026rsquo; specifies the title of the figure. The pair \u0026lsquo;NumberTitle\u0026rsquo;, \u0026lsquo;off\u0026rsquo; stops the figure being numbered.  This yields the following figure:\nWe than make a subplot in this figure to hold the results:\nh = subplot(\u0026#39;position\u0026#39;,[0.1 0.3 0.8 0.6]); The variables passed to \u0026lsquo;subplot\u0026rsquo; dictate the properties of the subplot.\nThe pair \u0026lsquo;position\u0026rsquo;,[0.1 0.3 0.8 0.6] specifies the xy-position of the subplot within the figure. The first two elements of the vector represent the position of the bottom left of the subplot from the bottom left of the figure, and the last two elements represent its width and height. All of these values are given as fractions of the total width or height.\nThis yields the following figure:\nUsing uicontrol Now we have the figure and axes defined, we can add the controls to the GUI. Elements of the GUI are added using the uicontrol command. For more details see doc uicontrol.\nThe uicontrol command can be used to add some descriptive text to the figure:\nuicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Parameter Value\u0026#39;, \u0026#39;Position\u0026#39;, [150 50 90 30]); The variables passed to uicontrol dictate the type of user interface.\n the pair \u0026lsquo;Style\u0026rsquo;, \u0026lsquo;text\u0026rsquo; says we want a textbox. the pair \u0026lsquo;String\u0026rsquo;, \u0026lsquo;Parameter Value\u0026rsquo; gives the contents of the textbox. the pair \u0026lsquo;Position\u0026rsquo;, [150 50 90 30] gives the position and size of the text measured in pixels from the bottom left of the figure.  The \u0026lsquo;uicontrol\u0026rsquo; command is also used to add a slider to the figure\nSlider = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;, 0, \u0026#39;Max\u0026#39;, 10, \u0026#39;Position\u0026#39;, [250 50 200 30]); The variables passed to uicontrol dictate the type of user interface.\n the pair \u0026lsquo;Style\u0026rsquo;, \u0026lsquo;slider\u0026rsquo; says we want a slider. the pairs \u0026lsquo;Min\u0026rsquo;, 0 and \u0026lsquo;Max\u0026rsquo;, 10 give the limits of the slider. the pair \u0026lsquo;Position\u0026rsquo;, [250 50 200 30] gives the position and size of the slider measured in pixels from the bottom left of the figure.  In order to have access to the slider within subfunctions we can define Slider to be a global variable in both the main function and all subfunctions. This is done by including the line:\nglobal Slider; in all functions in which it is used.\nFinally, the \u0026lsquo;uicontrol\u0026rsquo; command can be used to add a button to the figure\nButton = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;pushbutton\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Run\u0026#39;, \u0026#39;Position\u0026#39;, [530 50 100 30], \u0026#39;Callback\u0026#39;, @PlotGUI); The variables passed to uicontrol dictate the type of user interface.\n the pair \u0026lsquo;Style\u0026rsquo;, \u0026lsquo;pushbutton\u0026rsquo; says that we want a button, which executes some code when pressed. the pair \u0026lsquo;String\u0026rsquo;, \u0026lsquo;Run\u0026rsquo; give the text displayed on the button. the pair \u0026lsquo;Position\u0026rsquo;, [530 50 100 30] gives the position and size of the button measured in pixels from the bottom left of the figure. the pair \u0026lsquo;Callback\u0026rsquo;, @PlotGUI provide code to run the command \u0026lsquo;PlotGUI\u0026rsquo;, which can be any function when the button is pressed.  There are more user interfaces defined using uicontrol. See \u0026lsquo;doc uicontrol\u0026rsquo; for the full list.\nPutting all of this together\nfigure(\u0026#39;position\u0026#39;,[0 0 700 500], \u0026#39;name\u0026#39;,\u0026#39;SimpleGUI\u0026#39;,\u0026#39;NumberTitle\u0026#39;,\u0026#39;off\u0026#39;); h = subplot(\u0026#39;position\u0026#39;,[0.1 0.3 0.8 0.6]); uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Parameter Value\u0026#39;, \u0026#39;Position\u0026#39;, [150 50 90 30]); Slider = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;, 0, \u0026#39;Max\u0026#39;, 10, \u0026#39;Position\u0026#39;, [250 50 200 30]); Button = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;pushbutton\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Run\u0026#39;, \u0026#39;Position\u0026#39;, [530 50 100 30], \u0026#39;Callback\u0026#39;, @PlotGUI); gives the following figure:\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/05_using_the_inbuilt_help/",
	"title": "Using the inbuilt help",
	"tags": [],
	"description": "",
	"content": "The help facility within MATLAB is very extensive. You will be using the help files throughout this course to find out what a new function does when you first come across it.\nIf you know the name of the function in which you are interested, you can type help FunctionName.\nFor instance, typing help fft will display\n\u0026gt;\u0026gt; help fft fft Discrete Fourier transform. fft(X) is the discrete Fourier transform (DFT) of vector X. For matrices, the fft operation is applied to each column. For N-D arrays, the fft operation operates on the first non-singleton dimension. ... Instead, you can open the more extensive documentation pages by typing doc FunctionName. For instance, typing doc fft will open the following window:\nThe only real drawback is that you need to know not only that something is there but also what it is called. Fortunately, most of the MATLAB commands have sensible names and there is inbuilt search functionality for the graphical help.\nYou can just load the graphical help browser where you can search for the function you need by typing doc, which brings up the following window:\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/06_guis_part_2/",
	"title": "GUIs: part 2",
	"tags": [],
	"description": "",
	"content": "In the previous screens we have created the figure for the GUI and added some controls. We now need to get the GUI to do something. In the command to create the push button we called a function named PlotGUI, which is where the MATLAB code to be controlled by the GUI will go.\nThe plot function We now define the function PlotGUI which is called by the push button.\n%% Called by SimpeGUI to do the plotting % hObject is the button and eventdata is unused. function PlotGUI(hObject,eventdata) % Gets the value of the parameter from the slider. Param = get(Slider,\u0026#39;Value\u0026#39;); % Puts the value of the parameter on the GUI. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, num2str(Param),... \u0026#39;Position\u0026#39;, [460 55 60 20]); % Plots the Graph. x=linspace(0,10,1000); k = Param; y = sin(k*x); plot(x,y); end The function \u0026lsquo;PlotGUI\u0026rsquo; takes in two input arguments:\n hObject, the handle of the button which enables the state of the uicontrol to be accessed from PlotGUI. (Note: this is not used here as we are using global functions but is used in the code given below.) eventdata, unused here but included for use with the Callback command.  This function can be modified so that it runs the code you wish the GUI to control.\nThe whole thing Brought together, the entire GUI is defined by the following code:\n%% Simple GUI function SimpleGUI() close all global Slider; %Define this to be global so subfunction can see slider % Make a large figure. figure(\u0026#39;position\u0026#39;,[0 0 700 500], \u0026#39;name\u0026#39;, \u0026#39;SimpleGUI\u0026#39;, \u0026#39;NumberTitle\u0026#39;, \u0026#39;off\u0026#39;); % Make subplot to hold plot. h = subplot(\u0026#39;position\u0026#39;,[0.1 0.3 0.8 0.6]); % Just some descriptive text. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Parameter Value\u0026#39;,... \u0026#39;Position\u0026#39;, [150 50 90 30]); % A slider for varying the parameter. Slider = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;,0,\u0026#39;Max\u0026#39;, 10,... \u0026#39;Position\u0026#39;, [250 50 200 30]); % A button to run the sims. Button = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;pushbutton\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Run\u0026#39;,... \u0026#39;Position\u0026#39;, [530 50 100 30],\u0026#39;Callback\u0026#39;, @PlotGUI); %% Called by SimpeGUI to do the plotting % hObject is the button and eventdata is unused. function PlotGUI(hObject,eventdata) % Gets the value of the parameter from the slider. Param = get(Slider,\u0026#39;Value\u0026#39;); % Puts the value of the parameter on the GUI. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, num2str(Param),... \u0026#39;Position\u0026#39;, [460 55 60 20]); % Plots the Graph. x=linspace(0,10,1000); k = Param; y = sin(k*x); plot(x,y); end end Copy this into a new M-file in your working directory named SimpleGUI.m, and run it with the command:\nSimpleGui Move the slider and press the \u0026lsquo;Run\u0026rsquo; button see the plot change. The working GUI is shown in the following figure:\nWhile this is a very simple application, the methods used here can be extended to more general GUIs.\nAlternative GUI example Another version of this GUI is given below, which automatically updates the plot after the slider is moved:\n%% Simple GUI function SimpleGUIWithoutButton() close all % Make a large figure. figure(\u0026#39;position\u0026#39;,[0 0 700 500], \u0026#39;name\u0026#39;, \u0026#39;SimpleGUI\u0026#39;, \u0026#39;NumberTitle\u0026#39;, \u0026#39;off\u0026#39;); % Make subplot to hold plot. h = subplot(\u0026#39;position\u0026#39;,[0.1 0.3 0.8 0.6]); % Just some descriptive text. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Parameter Value\u0026#39;,... \u0026#39;Position\u0026#39;, [150 50 90 30]); % A slider for varying the parameter. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;,0,\u0026#39;Max\u0026#39;, 10,... \u0026#39;Position\u0026#39;, [250 50 200 30],\u0026#39;Callback\u0026#39;, @PlotGUI); %% Called by SimpleGUI to do the plotting % hObject is the slider and eventdata is unused. function PlotGUI(hObject,eventdata) % Gets the value of the parameter from the slider. Param = get(hObject,\u0026#39;Value\u0026#39;); % Puts the value of the parameter on the GUI. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, num2str(Param),... \u0026#39;Position\u0026#39;, [460 55 60 20]); % Plots the Graph. x=linspace(0,10,1000); k = Param; y = sin(k*x); plot(x,y); end end Copy this into a new M-file in your working directory named SimpleGUIWithoutButton.m, and run it with the command:\nSimpleGuiWithoutButton There are various other ways of constructing the GUI, and by now you will be sufficiently familiar with functions used in MATLAB to modify the files you have to experiment with this.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/06_numerical_methods/",
	"title": "Numerical methods",
	"tags": [],
	"description": "",
	"content": "The following sections are concerned with the theory underlying the numerical solution of ODEs such as numerical differentiation and Euler\u0026rsquo;s method.\nNumerical differentiation Recall from the previous unit \u0026lsquo;Basic calculus in MATLAB\u0026rsquo; that the derivative of a function $y$ with respect to the variable $x$ can be approximated by\n$$\\frac{dy}{dx}(x) \\approx \\frac{y(x) - y(x-\\delta x)}{\\delta x},$$ the backward difference formula; or\n$$\\frac{dy}{dx}(x) \\approx \\frac{y(x+\\delta x) - y(x)}{\\delta x},$$ the forward difference formula.\nwhere $\\delta x$ is small. The smaller $\\delta x$ is, the better the approximation. The notation here is slightly different from unit 3, since we are using $h=\\delta x$.\nEuler\u0026rsquo;s method for solving first order ODEs We wish to solve the first order ODE $$ \\frac{dy}{dx}=f(x,y) \\,,$$ subject to the initial condition $$ y(a)=y_a \\,,$$ on the domain $ a \\leq x \\leq b \\,.$\nWe will do this using Euler\u0026rsquo;s method and proceed as follows:\n  The first step is to divide the domain up into $n$ equally sized intervals of size $\\delta x=\\frac{b−a}{n}$.\n  Then we define $x^0=a$, $x^i=a+i\\delta x$ and $x^n=b$, and let $y^0=y_a$.\n  We now want to find a sequence of numbers $y^1 \\ldots y^n$ such that $y^i \\approx y(x^i)$. Using the approximations for the derivative from above we can approximate the first order initial value problem by $\\frac{y^{i+1}−y^i}{\\delta x}=f(x,y)$.\n  If we know $f(x,y)$, then rearranging this gives a formula for calculating $y^{i+1}$ given $y^i$.\nThere are various options for evaluating $f(x,y)$ which are discussed now.\nForward vs backward Euler Evaluating $f(x,y)$ at $x^i$ gives $$ \\frac{y^{i+1}−y^i}{\\delta x}=f(x^i,y^i) \\,, $$ which can be rearranged to give an explicit formula for $y^{i+1}$, $$ y^{i+1}=y^i+\\delta xf(x^i,y^i) \\,,$$ which is known as the forward Euler method.\nEvaluating $f(x,y)$ at $x^{i+1}$ gives $$ \\frac{y^{i+1}−y^i}{\\delta x} = f(x^{i+1},y^{i+1}) \\,,$$ which can be rearranged to give an implicit formula for $y^{i+1}$, $$ y^{i+1}−\\delta xf(x^{i+1},y^{i+1})=y^i \\,.$$ which is known as the backward Euler method. In general, this system is non-linear in $y^{i+1}$.\nIt is usually simpler to work out the forward Euler than the backward Euler approximation, but it is often possible to use a coarser mesh with the backward Euler method, since it remains stable for a larger step size.\nEuler method for systems of ODEs We can extend this to solve systems of first-order ODEs by treating $y$ as a vector ($\\mathbf{y}$) and $f$ as a vector of functions ($\\mathbf{f}$).\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/06_solution_of_nonlinear_equations/",
	"title": "Solution of nonlinear equations",
	"tags": [],
	"description": "",
	"content": "We very often need to find the zero of a complex non-linear function when working with mathematical modelling problems, perhaps most frequently when we wish to find the value (or values) of $x$ such that two functions, say $f$ and $g$, are equal, that is $f(x)=g(x)$. This problem is equivalent to letting $y(x)=f(x)−g(x)$ and determining the value(s) of $x$ such that $y(x)=0$.\nHere we will use the numerical methods of interval bisection and Newton\u0026rsquo;s method (also known as Newton–Raphson) to find the zero of a function.\nSummary of mathematics used Interval bisection Suppose $f(x)$ is a continuous function, such that $f(a)\u0026lt;0$ and $f(b)\u0026gt;0$. An approximation to $f(x)=0$ may be calculated using the following algorithm:\n  Let $c = \\frac{(a+b)}{2}$\n  If $f(c)\u0026lt;0$, then the root lies in the interval $[c,b]$, so let $a=c$. If $f(c)\u0026gt;0$, then the root lies in the interval $[a,c]$, so let $b=c$. If $f(c)=0$ then the root is at $x=c$\n  Repeat this process until you have a root to the desired accuracy.\n  Question Do this problem with pen and paper.\nModify this algorithm for the case $f(a)\u0026gt;0$ and $f(b)\u0026lt;0$\n Expand for solution Solution   Let $c = \\frac{(a+b)}{2}$\n  If $f(c)\u0026lt;0$, then the root lies in the interval $[a,c]$, so let $b=c$. If $f(c)\u0026gt;0$, then the root lies in the interval $[c,b]$, so let $a=c$. If $f(c)=0$ then the root is at $x=c$.\n  Repeat this process until you have a root to the desired accuracy.\n     Newton-Raphson Suppose that $f(x)$ is a continuous function. An approximation to $f(x)=0$ may be calculated using the following algorithm:\n  Start with an initial guess $x_0$.\n  Calculate the next solution using: $$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$$\n  Repeat step 2 until you have the root to the required accuracy.\n  For more details on Newton–Raphson see: https://mathworld.wolfram.com/NewtonsMethod.html\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/06_solving_axb_basic/",
	"title": "Solving $Ax=b$: basic",
	"tags": [],
	"description": "",
	"content": "Much of linear algebra is concerned with solving the linear system $Ax=b$. MATLAB has many inbuilt functions to do this, and in this section you will learn how to use them.\nThe two easiest methods for calculating the solution to $Ax=b$ are to calculate the inverse, using inv or the \\ (backslash) operator. The former calculates the inverse explicitly while the latter calculates the solution to $Ax=b$ using an appropriate numerical technique, such as Gaussian elimination. If you are not familiar with Gaussian elimination, see any textbook on linear algebra, or the Wolfram Mathworld page.\nWe will now go through an example of using these two solution methods.\nWalkthrough Let\nA=randn(4096); b=randn(4096,1);  Question Solve $Ax=b$ using both of the methods described above and time how long each method takes:\ntic, x1=inv(A)*b; toc tic, x2=A\\b; toc plot(x1-x2) What is the error between the two solutions and which was quicker?\n Expand for solution Solution Depending on your computer, the \\ backslash operator will probably take less than half the time of explicitly calculating the inverse. Plotting x1-x2\nshows that the maximum error is roughly 1e-12, which can be confirmed by calculating max(abs(x1-x2)) which, for this random linear system, yields 1.0467e-12.\nYour answer will be different due to the randomness of A and b.\n   Now clear the workspace\nclear The following code calculates the efficiency of the two solution methods for progressively larger systems. (Note that this plots the data using a log vs. log plot (help loglog) as the values grow exponentially.)\n% we will perform 20 repeats on 12 problem sizes num_repeats=20; num_problems=12; % % 2, 4, 8, 16, ..., 4096 problem_sizes=2.^(1:num_problems); % % pre-allocate two matrices to store the times in times_inv=zeros(num_repeats,num_problems); times_slash=zeros(num_repeats,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); for repeat=1:num_repeats % create the random matrix A and vector b A=randn(problem_size); b=randn(problem_size,1); % time the two methods of solving Ax=b tic; x1=inv(A)*b; times_inv(repeat,problem)=toc; tic; x2=A\\b; times_slash(repeat,problem)=toc; end end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,mean(times_inv),\u0026#39;rx\u0026#39;,... problem_sizes,mean(times_slash),\u0026#39;bo\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to solve a matrix problem using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) First, read the code above and make sure you understand what it does. Next, run the code. It may take up to a minute, depending on your computer.\nQuestion What does the resulting plot tell you about the speeds of the two methods?\n Expand for solution Solution Running the above code produces the following figure:\nThis shows that, once the linear system is large enough (about 16x16), then backslash is always faster than calculating the inverse. Because the matrices are generated randomly, the code averages over a number of repeats to try and understand the average behaviour.\nThis is an artificial problem, but later you will see how an approach to a \u0026lsquo;real world\u0026rsquo; problem is affected by the choice of solution methods.\nCan you think of any reasons that 4x4 systems might be quicker to solve than 2x2 systems? Why might the inverse be faster than backslash for 4x4 systems?\n   Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/06_vectors_and_matrices_part_1/",
	"title": "Vectors and matrices: part 1",
	"tags": [],
	"description": "",
	"content": " Info The main data structures in MATLAB are vectors and matrices. If you have never heard of these before, then look them up in:\n an A-level textbook, on the Wolfram MathWorld pages, or on Wikipedia  before you continue.\n Vectors Vectors in MATLAB are $n\\times 1$ or $1\\times n$ arrays of numbers.\nWalkthrough Suppose the vector $u$ is given by $u=(1\\;4\\;9)$. This may be entered into MATLAB in either of the following ways:\n  By entering each entry of the matrix individually.\nu(1)=1; u(2)=4; u(3)=9; Note that u(1) corresponds to the first entry of u, etc.\n  By typing the entries inside square brackets separated by spaces:\nu=[1 4 9];   The transpose of u may be printed by typing u'.\nSuppose the vector $v$ is given by: $$v=\\begin{pmatrix}4\\\\5\\\\6\\end{pmatrix}$$\nThis may be entered by typing:\nv = [4;5;6]; Inside the square brackets the semicolon denotes a new row.\nNote Vectors are sometimes referred to as arrays. This may be confusing so always look at the dimensions of the array to check the type.\n The length of a vector v can be found by using the command length(v), which here gives:\n\u0026gt;\u0026gt; length(v) ans = 3 The size of a vector v can be found by using the command size(v), which here gives:\n\u0026gt;\u0026gt; size(v) ans = 3 1 This tells us that v has 3 rows and 1 column, and thus allows us to distinguish it from u, which has 1 row and 3 columns.\nNow look up the commands length and size in the help files:\nhelp length help size Matrices Matrices in MATLAB are $m\\times n$ arrays of numbers.\nWalkthrough Suppose the matrix $A$ is given by: $$A=\\begin{pmatrix}1\u0026amp;2\\\\3\u0026amp;4\\end{pmatrix}$$\nThis may be entered into MATLAB in either of the following ways:\n  By entering each entry of the matrix individually\nA(1,1)=1; A(1,2)=2; A(2,1)=3; A(2,2)=4;   Note The entry $A(i,j)$ corresponds to the entry in row $i$ and column $j$ of the matrix $A$.\n  By typing\nA=[1 2; 3 4];   Note Use of ; inside the square brackets denotes a new row in the matrix.\n The dimensions of a matrix A can be found by using the command size(A), which here gives\n\u0026gt;\u0026gt; size(A) ans = 2 2  Note Running the command length(A) on a matrix A yields the result 2, which is the bigger dimension of the matrix, so if A were a $4\\times 6$ or a $6\\times 4$ matrix, length(A) would yield the answer 6.\n Editing vectors and matrices Walkthrough Editing vectors and matrices can be done by specifying the individual element. For example, to change the value of 2 in the matrix A, above, to 5 we can type\nA(1,2)=5; An alternative method is to double-click on A in the Workspace window. This opens a window containing the contents of the matrix A. Click on the entry in the first row, second column, and change it to 5.\nLooking at parts of matrices Sometimes we may wish to access only certain parts of a matrix or vector. There are a number of inbuilt MATLAB commands to help with this.\nWalkthrough The matrix $$C=\\begin{pmatrix}1\u0026amp;2\u0026amp;3\u0026amp;4\\\\5\u0026amp;6\u0026amp;7\u0026amp;8\\\\9\u0026amp;10\u0026amp;11\u0026amp;12\\end{pmatrix}$$\nmay be entered in MATLAB as\nC=[1 2 3 4; 5 6 7 8; 9 10 11 12]; To view the whole matrix we would type\nC To view the second column we would type\nC(:,2) To view the third row we would type\nC(3,:) To view the first two rows we would type\nC(1:2,:) To view the elements in both the last two rows and the last three columns we would type\nC(2:3,2:4)  Note The following: C(2:end,2:end) would yield the same result.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/07_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": " Question Using the GUI provided in the previous section as a guide, create a GUI for the system of differential equations given by:\n$$\\frac{dN}{dt}=N(1-P)$$ $$\\frac{dP}{dt}=P(N-1),$$\nwith initial conditions $N(0)=\\alpha$ and $P(0)=\\beta$. If you\u0026rsquo;re interested in the biological background for this problem (which is known as a \u0026lsquo;Predator–Prey system\u0026rsquo;), then see Chapter 3 of Mathematical Biology by J. D. Murray.\nYour GUI should plot both the solutions, $N$ and $P$ over time, together with the phase plane (how $P$ varies with $N$). It should include two inputs (sliders) in order to vary the initial conditions, $\\alpha$ and $\\beta$, and a button that is used to start the simulations.\n Expand for solution Solution The following file, PredPreyGUI.m, presents a suitable GUI for the predator– prey system described in the problem.\n% GUI for the Predator Prey System function PredPreyGUI() % global Slider1 Slider2; %Define these to be global so subfunction can see slider % close all % % Make a large figure. figure(\u0026#39;position\u0026#39;,[0 0 1000 600],\u0026#39;name\u0026#39;,\u0026#39;PredatorPreyGUI\u0026#39;,\u0026#39;NumberTitle\u0026#39;,\u0026#39;off\u0026#39;); % % Make subplots to hold plots h_1 = subplot(\u0026#39;position\u0026#39;,[0.05 0.25 0.4 0.65]); h_2 = subplot(\u0026#39;position\u0026#39;,[0.55 0.25 0.4 0.65]); % % Just some descriptive text. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Alpha\u0026#39;,... \u0026#39;Position\u0026#39;, [50 55 90 20]); % % A slider for varying the first parameter. Slider1 = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;,0,\u0026#39;Max\u0026#39;, 2,... \u0026#39;Position\u0026#39;, [150 55 200 20]); % % Just some descriptive text. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Beta\u0026#39;,... \u0026#39;Position\u0026#39;, [450 55 90 20]); % % A slider for varying the second parameter. Slider2 = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;slider\u0026#39;, \u0026#39;Min\u0026#39;,0,\u0026#39;Max\u0026#39;, 2,... \u0026#39;Position\u0026#39;, [550 55 200 20]); % % A button to run the simulations. Button = uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;pushbutton\u0026#39;, \u0026#39;String\u0026#39;, \u0026#39;Run\u0026#39;,... \u0026#39;Position\u0026#39;, [850 50 100 30],\u0026#39;Callback\u0026#39;, @PlotGUI); % %% Called by PredPreyGUI to do the solving and plotting % hObject is the button and eventdata is unused. function PlotGUI(hObject,eventdata) % % Gets the value of the parameters from the sliders. alpha = get(Slider1,\u0026#39;Value\u0026#39;); beta = get(Slider2,\u0026#39;Value\u0026#39;); % % Puts the value of the parameters on the GUI. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, num2str(alpha),... \u0026#39;Position\u0026#39;, [360 55 60 20]); % % Puts the value of the parameters on the GUI. uicontrol(\u0026#39;Style\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;String\u0026#39;, num2str(beta),... \u0026#39;Position\u0026#39;, [760 55 60 20]); % % Solves the ODEs EndTime = 20; [t,Y] = ode45(@PredPrey,[0,EndTime],[alpha,beta]); % % Plot the Solutions h_1 = subplot(\u0026#39;position\u0026#39;,[0.05 0.25 0.4 0.65]); plot(t,Y(:,1),\u0026#39;b\u0026#39;,t,Y(:,2),\u0026#39;r\u0026#39;); legend(\u0026#39;Prey (N)\u0026#39;,\u0026#39;Predator (P)\u0026#39;); h_2 = subplot(\u0026#39;position\u0026#39;,[0.55 0.25 0.4 0.65]); plot(Y(:,1),Y(:,2),\u0026#39;b\u0026#39;); xlabel(\u0026#39;N\u0026#39;); ylabel(\u0026#39;P\u0026#39;); % %% Function defining the Predator Prey System. function dYdt = PredPrey(t,Y) % dYdt = [ Y(1)*(1-Y(2)); Y(2)*(Y(1)-1)]; end end end Copy this into a new M-file in your working directory named PredPreyGUI.m, and run it with the command:\nPredPreyGUI Move the sliders and press the \u0026lsquo;Run\u0026rsquo; button see the plot change. The working GUI is shown in the following figure:\nNow that you understand the basics of making GUIs in MATLAB, you can use the inbuilt \u0026lsquo;App Designer\u0026rsquo; development environment to make GUIs using a graphical interface. See Create and Run a Simple App Using App Designer for more information. You will not be required to use App Designer for this course but you may find it useful if you need to make a complicated GUI in the future.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/07_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to give you familiarity with the numerical methods used to solve first-order ODEs. Hints and solutions are available.\nQuestion Write a Matlab script to solve $$ \\frac{dy}{dx} = y $$ subject to $y(0) = 1$ on the domain $0 \\leq x \\leq 5$, using both forward and backward Euler methods.\n Expand for hint Hint The forward Euler formula gives, on rearrangement $$ y^{i+1} = y^i + \\delta x \\times y^i \\,. $$ In MATLAB, this can be implemented as\nyForward(i+1) = (1+dx)*yForward(i); for suitably defined variables in an appropriate loop.\nSimilarly, the backward Euler formula gives, on rearrangement $$ y^{i+1} = y^i + \\delta x \\times y^{i+1} $$ In MATLAB, this can be implemented as\nyBackward(i+1) = yBackward(i)/(1-dx); for suitably defined variables in an appropriate loop.\n   How do the approximations compare to the exact solution? What happens as you increase the number of points in your approximation $n$?   Expand for solution Solution The exact solution is: $$ y=e^x \\,.$$ Code to solve this equation numerically is given below.\n% Code to implement the Forward and % Backward Euler methods to solve dy/dx=y. clear close all % N = 50; % Number of intevals EndTime = 5; dx = EndTime/N; x=linspace(0,EndTime,N+1); yExact = exp(x); % Exact solution % yForward = zeros(1,N+1); yBackward = zeros(1,N+1); % % Specify inital conditions yForward(1) = 1; yBackward(1) = 1; % for i = 1:N yForward(i+1) = (1+dx)*yForward(i); yBackward(i+1) = yBackward(i)/(1-dx); end % plot(x,yExact,\u0026#39;k\u0026#39;,x,yForward,\u0026#39;b+\u0026#39;,x,yBackward,\u0026#39;rx\u0026#39;); legend(\u0026#39;Exact\u0026#39;,\u0026#39;Forward Euler\u0026#39;,\u0026#39;Backward Euler\u0026#39;); Running this code produces the following figure:\nFor this problem, the forward Euler method always underestimates the solution, while the backward Euler method always overestimates it. This is because the gradient of the solution is always increasing.\nBy running the script and varying $n$ we see that as $n$ increases, the accuracy of the approximations also increases.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/07_exercises_3/",
	"title": "Exercises 3",
	"tags": [],
	"description": "",
	"content": " Question Let $f(x) = x^3 - 1 $.\n  Use the bisection method on the interval $[−1,10]$ to calculate the root of $f(x)=0$ correct to two decimal places. How many bisections were necessary?\n  Use Newton–Raphson with $x_0=10$ to calculate the root of $f(x)=0$ correct to two decimal places. How many iterations were necessary?\n   Expand for solution Solution   14 bisections are required for interval bisection:\nclear % %% The function, interval and tolerance theFunction=@(x)x^3-1; theInterval=[-1,10]; theTolerance=0.001; % %% Interval bisection method NumberOfBisections=0; % Initialising a=theInterval(1); b=theInterval(2); % while (b-a \u0026gt; theTolerance) c=(a+b)*0.5; fa=theFunction(a); fc=theFunction(c); if (fa*fc \u0026gt; 0) a=c; elseif (fa*fc \u0026lt; 0) b=c; else b=a; end % % Increment number of bisections NumberOfBisections=NumberOfBisections+1; end % root = c NumberOfBisections   9 iterations are required for Newton–Raphson. Example code to solve this is given below:\nclear % %% The function, starting value and tolerance theFunction=@(x)x^3-1; theDerivative=@(x)3*x*x; theInitialGuess=10; theTolerance=0.001; % %% Newton-Raphson method x=theInitialGuess; % Initialising diff=1; % Initialising NumberOfIterations=0; % Initialising % while (diff \u0026gt; theTolerance) y=x - theFunction(x)/theDerivative(x); diff=abs(y-x); % calculate |x_(n+1) - x_n| x=y; % Update solution approximation % % Increment number of iterations NumberOfIterations=NumberOfIterations+1; end % root = x NumberOfIterations      Question  Repeat the previous question for $f(x)=x^5+ \\frac{x}{1000000}$.   Expand for hint Hint Modify the code from the previous answer. All you need to change is the function definitions.\n  Comment on the convergence speed for Newton–Raphson in this question in comparison with that in the previous question. What is the reason for the difference.   Expand for solution Solution 14 bisections are required for the bisection method and 30 iterations are required for Newton–Raphson in this case.\n  Example code to solve this using the bisection method is given below:\nclear % %% The function, interval and tolerance theFunction=@(x)x^5+x*1e-6; theInterval=[-1,10]; theTolerance=0.001; % %% Interval bisection method NumberOfBisections=0; % Initialising a=theInterval(1); b=theInterval(2); % while (b-a \u0026gt; theTolerance) c=(a+b)*0.5; fa=theFunction(a); fc=theFunction(c); if (fa*fc \u0026gt; 0) a=c; elseif (fa*fc \u0026lt; 0) b=c; else b=a; end % % Increment number of bisections NumberOfBisections=NumberOfBisections+1; end % root = c NumberOfBisections Example code to solve this using Newton–Raphson is given below:\nclear % %% The function, starting value and tolerance theFunction=@(x)x^5+x*1e-6; theDerivative=@(x)5*x^4+1e-6; theInitialGuess=10; theTolerance=0.001; % %% Newton-Raphson method x=theInitialGuess; % Initialising diff=1; % Initialising NumberOfIterations=0; % Initialising % while (diff \u0026gt; theTolerance) y=x - theFunction(x)/theDerivative(x); diff=abs(y-x); % calculate |x_(n+1) - x_n| x=y; % Update solution approximation % % Increment number of iterations NumberOfIterations=NumberOfIterations+1; end % root = x NumberOfIterations   The convergence speed is slower for Newton–Raphson because the derivative of this function is very small in the region of the root.\n     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/07_solving_axb_iterative/",
	"title": "Solving $Ax=b$: iterative",
	"tags": [],
	"description": "",
	"content": "This section is appropriate if you have a background in mathematics and have encountered matrices before. If not then feel free to attempt this section however the material assumes a relatively high level of knowledge of linear algebra.\nMATLAB has many inbuilt methods for solving $Ax=b$. Many of these are iterative and suitable for different kinds of matrices. If you have information about the structure of $A$ and know which iterative solver is the best to use (see Linear Algebra and its Applications by Gilbert Strang for details), you can specify the solver in MATLAB. The help files will specify the types of matrix to which they should be applied. We will now use two of these solvers based on the \u0026lsquo;conjugate gradient\u0026rsquo; method.\nWalkthrough Create a Symmetric Positive Definite (SPD) matrix (and check that it is SPD) by using the following commands:\nA=randn(50); % Make sure A is SPD A=A*A\u0026#39;; % Verify that this gives us a symmetric matrix spy(A-A\u0026#39;) find((A-A\u0026#39;)\u0026gt;1e-10) % check positive definite: all eigenvalues \u0026gt; 0 e=eig(A); min(e) Create a suitable right-hand side $b$:\nb=sum(A,2);  Question With $A$ and $b$ defined as above, what is the exact solution to $Ax=b$?\n Expand for solution Solution Every element of $x$ should be exactly 1. If this is not clear, make sure you understand what sum(A,2) is doing, and try writing out a 3x3 system by hand.\n   Calculate $x$ using the preconditioned Conjugate Gradient method (CG) (see Linear Algebra and its Applications by Gilbert Strang for details if you are interested). Note that $A$ must be SPD to use this solver. Try using it on a non-SPD matrix.\nx1=pcg(A,b); x2=pcg(A,b,1e-6,100); What does the second command do differently? Look at doc pcg. Now look at the solutions:\nformat long max(abs(x1-x2)) plot(x1-x2) This gives the following figure for the error $x1-x2$:\nwhich shows that the solutions are not the same.\nQuestion Why is this?\n Expand for solution Solution When running the command\nx1=pcg(A,b); you should have received the following output:\n\u0026gt;\u0026gt; x1=pcg(A,b); pcg stopped at iteration 20 without converging to the desired tolerance 1e-06 because the maximum number of iterations was reached. The iterate returned (number 19) has relative residual 0.0019. Therefore the method did not converge in the given maximum number of steps. It defaults to 20. The command\nx2=pcg(A,b,1e-6,100); sets the maximum number of iterations at 100, which is enough for the method to converge.\n   Now clear the workspace\nclear The Biconjugate Gradient method can be used in a similar way. Note that $A$ does not have to be SPD in this case.\nA=randn(50); b=sum(A,2); x=bicg(A,b,1e-6,100); plot(x) Now clear the workspace\nclear To learn more about these iterative methods, see:\ndoc pcg doc bicg doc bicgstab doc gmres "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/07_vectors_and_matrices_part_2/",
	"title": "Vectors and matrices: part 2",
	"tags": [],
	"description": "",
	"content": "Now that we know how to handle matrices and vectors in MATLAB, we will look at how to perform operations on them.\nAddition, subtraction and multiplication of vectors and matrices If two vectors or matrices are of the correct size, then they may be added, subtracted or multiplied using the standard operators +, - and *.\nWalkthrough For example, enter the following vectors and matrices:\nu=[1 2]; v=[3; 4]; A=[1 2; 3 4]; B=[5 6; 7 8]; The following are valid operations:\nu*v v*u A+B A-B A*B A*v u*A (A+B)*v but\nA*u is not. Try entering the above operations in the command line.\nQuestion What do the above operations represent and what is the result: a matrix; a vector; or a scalar?\n Expand for solution  u*v – inner product (dot product) – scalar (1 x 1). v*u – vector outer product – matrix (2 x 2). A+B – matrix addition – matrix (2 x 2). A-B – matrix subtraction – matrix (2 x 2). A*B – matrix multiplication – matrix (2 x 2). A*v – right multiplication of a matrix by a vector – vector (2 x 1). u*A – left multiplication of a matrix by a vector – vector (1 x 2). (A+B)*v – matrix addition and right multiplication – vector (2 x 1).    Question Why is A*u not a valid operation?\n Expand for solution The product A*u would represent right multiplication of a 2 x 2 matrix by a 1 x 2 vector, which is an incompatible matrix multiplication. The appropriate dimensions must agree to use the * operator. Similarly, v*A would also fail.\nAttempting an incompatible matrix multiplication will result in an error like this:\n\u0026gt;\u0026gt; A*u Error using * Incorrect dimensions for matrix multiplication. Check that the number of columns in the first matrix matches the number of rows in the second matrix.    Element-wise operations Often we wish to perform operations on elements of a vector or a matrix. We may, for example, have a vector of numbers and wish to calculate their squares. This is done using the \u0026lsquo;dot\u0026rsquo; command, '.'\nWalkthrough For example, enter the following vectors:\nu=[1 2 3 4]; v=[5 6 7 8]; To calculate the square of all elements of u use the command:\nu.^2 To multiply each element of u by the corresponding element of v use:\nu.*v This also works with matrices, for example:\nA.^2  Note This only works if the sizes of the vectors/matrices are the same. It is good practice to clear your variables once you have finished using them.\n Generating vectors It can be tedious to input vectors by specifying all the entries manually; the following are two methods to define vectors more quickly.\nWalkthrough A row vector x consisting of integers from 1 to 10 inclusive may be generated by typing:\nx=1:10 Furthermore, a row vector x consisting of every odd integer from 1 to 9 inclusive may be generated by typing\nx=1:2:9 The central variable indicates the step size, so\nx=10:-1:1 would yield a row vector consisting of the integers from 1 to 10 inclusive, but in descending order.\nA vector y consisting of 100 points equally spaced between 5 and 15 may be generated by typing\ny=linspace(5,15,100) look up the linspace command in the MATLAB help system.\nSome special matrices and vectors MATLAB has inbuilt commands that can be used to create some simple matrices, which can be adapted using your own code to construct matrices of interest to you. You will see examples of this in later units.\nWalkthrough The 3 x 4 matrix with all entries equal to 0 may be produced using the command\nzeros(3,4) The 5 x 2 matrix with all entries equal to 1 may be produced using the command\nones(5,2) The 4 x 6 matrix with diagonal entries equal to 1 and all other entries equal to 0 is given by\neye(4,6) The 2 x 1 matrix (that is, a column vector of length 2) with entries that are distributed randomly with a uniform distribution on the interval $[0,1]$ is given by\nrand(2,1) The 1 x 3 matrix (that is, a row vector of length 3) with entries uniformly distributed with mean 0 and standard deviation 1 is given by\nrandn(1,3) If the matrix required with any of the commands in this section is square, then the second index is not required, as for example with\nones(4) rand(2) "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/08_complex_numbers/",
	"title": "Complex numbers",
	"tags": [],
	"description": "",
	"content": " Info MATLAB can also handle complex numbers. If you have never heard of these before, then look them up in:\n an A-level textbook, on the Wolfram MathWorld pages, or on Wikipedia  before you continue.\n Walkthrough Complex numbers may be entered as, for example,\nz=3+4i The real part, imaginary part, magnitude, argument (in radians) and complex conjugate of z may be evaluated using the following commands:\nreal(z) imag(z) abs(z) angle(z) conj(z)  Question Question: What are the results of the above operations?\n Expand for solution  real(z) = 3. imag(z) = 4. abs(z) = 5. angle(z) = 0.9273. conj(z) = 3-4i.    "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/08_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "The following exercise is the final one in the unit and it will allow you to practise using MATLAB to solve linear systems and give you an insight into which methods to use.\nLet $A$ be a sparse symmetric positive definite matrix of dimension $(N-1)^2\\times (N-1)^2$ defined in buildA.m from the previous question, and let $f$ be the vector of dimension $(N-1)^2$ entered in MATLAB (for a given $N$) by the function:\nfunction f=buildf(N) x=0:1/N:1; y=x; f=sin(pi*x)\u0026#39;*sin(pi*y); f=reshape(f(2:N,2:N),(N-1)^2,1); end Copy this function to a file called buildf.m in your current working directory.\nIn this exercise we will consider the solution of the linear system $Au=f$, which corresponds to a finite difference solution to Poisson\u0026rsquo;s equation $-\\nabla^2u=f$ on the unit square, with zero Dirichlet boundary conditions, where $f=\\sin(\\pi x)\\sin(\\pi y)$. Partial differential equations of this type occur very frequently (usually with some additional reaction and or convection terms) in mathematical modelling of physical and biological processes, and even in image analysis.\nQuestion For $N=4,\\,8,\\,16,\\,32,\\,64,\\,128,\\,256,\\,512$, try the following:\n Solve the linear systems $Au=f$ by explicitly calculating $A^{-1}$ and calculating $u=A^{-1}f$ and record the time this takes on a log–log graph. (Omit the cases $N=128,\\,256,\\,512$ as the program may run out of memory or take an awfully long time.)   Expand for hint Hint You may wish to use the following code from the earlier walkthrough as a starting point:\n% we will perform 20 repeats on 12 problem sizes num_repeats=20; num_problems=12; % % 2, 4, 8, 16, ..., 4096 problem_sizes=2.^(1:num_problems); % % pre-allocate two matrices to store the times in times_inv=zeros(num_repeats,num_problems); times_slash=zeros(num_repeats,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); for repeat=1:num_repeats % create the random matrix A and vector b A=randn(problem_size); b=randn(problem_size,1); % time the two methods of solving Ax=b tic; x1=inv(A)*b; times_inv(repeat,problem)=toc; tic; x2=A\\b; times_slash(repeat,problem)=toc; end end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,mean(times_inv),\u0026#39;rx\u0026#39;,... problem_sizes,mean(times_slash),\u0026#39;bo\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to solve a matrix problem using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;)    Solve the linear systems using Gaussian elimination (corresponding to MATLAB\u0026rsquo;s \\ command). Plot the time this takes on the same graph.   Expand for solution Solution The following MATLAB code calculates both of these and plots them on the same graph:\n% no repeats this time: the matrices are not random num_problems=8; % % 4, 8, 16, ..., 512 problem_sizes=2.^(2:1+num_problems); % % pre-allocate a matrix to store the times times=zeros(2,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); % create the A and f A=buildA(problem_size); f=buildf(problem_size); % time the two methods of solving Au=f if problem_size\u0026lt;128 tic; u1=inv(A)*f; times(1,problem)=toc; end tic; u2=A\\f; times(2,problem)=toc; end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,times(1,:),\u0026#39;x-\u0026#39;,... problem_sizes,times(2,:),\u0026#39;o-\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to linear system using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) This yields the following figure:\nNote that backslash is faster than calculating the inverse explicitly for all problem sizes bigger than $N=4$, and backslash solves the $(N-1)^2\\times (N-1)^2$ system even for $N=512$ in under a second.\nCalculating the inverse fails for $N=128$ is infeasible in a sensible amount of time.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/08_fourier_series/",
	"title": "Fourier series",
	"tags": [],
	"description": "",
	"content": "Fourier series can be used to approximate a general periodic function, even with discontinuities. It does this by using the sum of continuous sine and cosine waves.\nSummary of mathematics used The Fourier series of the periodic function $f(x)$ defined on the domain $[−\\pi,\\pi]$ such that $f(x)+f(x+2\\pi)$ is given by:\n$$f(x) = \\frac{1}{2}a_0 + \\sum_{n=1}^{\\infty} \\left( a_n\\cos{nx} + b_n\\sin{nx} \\right)$$\nwhere\n$$a_0 = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\,dx$$\nand\n$$a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\cos{nx}\\,dx \\textrm{, and} \\quad b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\sin{nx}\\,dx \\quad \\textrm{for}\\, n = 1,2,\\ldots.$$\nThis formula can be extended to functions with an arbitrary period. In addition, any function defined on an interval $[a,b]$ can be extended to a periodic function, with period $b−a$, for which a Fourier series can be calculated. For more details on the mathematics underlying Fourier series see https://mathworld.wolfram.com/FourierSeries.html and the references contained within it.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/08_initial_value_problems/",
	"title": "Initial value problems",
	"tags": [],
	"description": "",
	"content": "Problem definition Consider systems of first order equations of the form $$ \\frac{dy_1}{dx} = f_1(x,y_1,y_2) \\,, $$ $$ \\frac{dy_2}{dz} = f_2(x,y_1,y_2) \\,, $$ subject to conditions $y_1(x_0)=y_{1_0}$ and $y_2(x_0)=y_{2_0}$. This type of problem is known as an Initial Value Problem (IVP). In order to solve these we use the inbuilt MATLAB commands ode45 and ode15s, both of which use the same syntax so that once you can use one you can use the other. (There is a larger family of ODE solvers that use the same syntax. See doc ode45 for a full list.).\nThis family of solvers is based on multi-step methods such as Runge–Kutta schemes, which extend the Euler methods discussed in the previous section. For more details, see any book on numerical methods of solving differential equations or https://mathworld.wolfram.com/Runge-KuttaMethod.html. (Note that this is beyond the scope of this present course.) Use doc ode45 to find more details on these solvers.\nIn this section we will demonstrate how to use the inbuilt MATLAB ODE solvers such as ode45. We will demonstrate how this works through two walkthroughs: a single first-order ODE and a coupled system of first-order ODEs.\nMatlab commands We wish to solve $$ \\frac{dy}{dx} = f(x,y) $$ subject to $y(x_0) = y_0$, for given values $x_0$ and $y_0$.\nUse of the inbuilt MATLAB ODE solvers requires the following steps:\n  We construct a function (here called deriv) which has input arguments $x$ and $y$ and returns the value of the derivative $\\frac{dy}{dx}$, that is $f(x,y)$.\n  We call the ODE solver (here ode45) using the following command\n[x,y] = ode45(@deriv,[x0,x1],y0); The variables and parameters passed to the ODE solver are:\n  @deriv, a handle to a function that returns the value of the derivative $\\frac{dy}{dx}$ for a given $x$ and $y$;\n  [x0,x1], the range of $x$ for which the problem is to be solved; and\n  y0, the initial condition for $y$, $ y(x_0)=y_0$.\n    We plot the results, which are now stored as $x$ and $y$.\n  Walkthrough - Single ODE Suppose we wish to solve\n$$ \\frac{dy}{dx} = xy \\,,$$\nsubject to $y(0) = 1$\nusing the Matlab solver ode45.\nExample code to solve this is given by\n% Function to solve dydx=xy. function SolveSimple(y0) [x,y] = ode45(@deriv,[0,1],y0); plot(x,y,\u0026#39;b-x\u0026#39;); % A function defining the derivative function dydx = deriv(x,y) dydx = x*y; end end The main elements of this code are\n  [x,y] = ode45(@deriv,[0,1],y0); Which is the call to the ode45 solver, whose parameters are:\n  @deriv a handle to a function that returns the value of the derivative $\\frac{dy}{dx}$ given $x$ and $y$;\n  [0,1] the range for which the problem is to be solved; and\n  y0 the initial condition for $y$, $y(0)=y_0$ (where $y_0$ is a number).\n    function dydx = deriv(x,y) which is a function that returns the value of $\\frac{dy}{dx}$ for a given $x$ and $y$ (here $xy$).\n  Running the code, by saving in a file named SolveSimple.m and executing it with SolveSimple(1), yields the following plot:\nThis is plotted against the exact solution $y=e^{\\frac{x^2}{2}}$, in the next figure:\nThe red line represents the actual solution and the blue crosses show the numerical solution from ode45.\nYou can also use ode45 to solve systems of first-order ODEs (and also higher-order equations by reducing them to systems of first-order equations) as shown in the following walkthrough.\nWalkthrough - Coupled systems of equations Suppose we wish to solve $$ \\frac{dy_1}{dx} = -y_2 $$ $$ \\frac{dy_2}{dx} = y_1 $$ subject to $y_1(0) = 1$ and $y_2(0) = 0$.\nExample code to solve this is given by\n% Function to solve the simple coupled ODE system. function SolveCoupled() y10=1; y20=0; [x,Y] = ode45(@coupled,[0,5],[y10;y20]); % plot(x,Y(:,1),\u0026#39;b\u0026#39;,x,Y(:,2),\u0026#39;r\u0026#39;); legend(\u0026#39;y_1\u0026#39;,\u0026#39;y_2\u0026#39;) % function dYdt = coupled(x,Y) dYdt=[-Y(2);Y(1)]; end end This code is very similar to the code for the single ODE but here Y and dYdt are now vectors.\nThe main elements of this code are\n  [x,Y] = ode45(@coupled,[0,5],[y10;y20]); which is the call to the ode45 solver, the various parameters are:\n  @coupled, a handle to a function that returns the value of the derivative $\\frac{dy}{dx}$ for given $x$ and $y=(y1,y2)$;\n  [0,5], the range for which the problem is to be to solved;\n  [y10;y20], the initial conditions for $y1$ and $y2$; and\n    Y, the solution in the form of a matrix, in which the first column is the solution for $y_1$ and the second is the solution for $y_2$.\n  function dYdx = coupled(x,Y) which is a function that returns the value of $\\frac{dy}{dx}$ for a given $x$ and $\\mathbf{y}$. Note that this is now a vector.\n  plot(x,Y(:,1),'b',x,Y(:,2),'r'); which plots the solutions for $y_1$ and $y_2$, in blue and red respectively.\n  Running the code, by saving in a file named SolveCoupled.m and executing it with SolveCoupled(), yields the following plot:\nWhich agrees with the analytical solution of $y_1=\\cos(x)$ and $y_2=\\sin(x)$ calculated earlier.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/08_making_movies_in_matlab/",
	"title": "Making movies in MATLAB",
	"tags": [],
	"description": "",
	"content": "If you are going to make a presentation then you may want to make a movie that you can include within it. The following example will show how to use the commands\n getframe VideoWriter writeVideo  to make a movie in MATLAB. Before going through the walkthrough look at the help files for the above commands.\nWalkthrough Here we are going to make a movie of an oscillating surface.\nThe full code looks like this:\nclear; close all; % Create a video writer object, set to create an mp4 v = VideoWriter(\u0026#39;peaks.mp4\u0026#39;, \u0026#39;MPEG-4\u0026#39;); open(v); % Create a 3D surface for the video Z = peaks(50); surf(Z); axis tight manual set(gca,\u0026#39;nextplot\u0026#39;,\u0026#39;replacechildren\u0026#39;); % Create 80 frames where the surface oscillates for k = 1:80 surf((1 + cos(6*pi*k/80) + cos(2*pi*k/80))* 0.3333 * Z,Z) frame = getframe(gcf); writeVideo(v,frame); end close(v); It produces the following video:\n  First, let\u0026rsquo;s look at the VideoWriter object:\nv = VideoWriter(\u0026#39;peaks.mp4\u0026#39;, \u0026#39;MPEG-4\u0026#39;); open(v); ... close(v); Here, we create a VideoWriter, set the filename of the resulting video to \u0026lsquo;peaks.mp4\u0026rsquo;, and set the video format to \u0026lsquo;MPEG-4\u0026rsquo;. We also have to open the video writer, execute the code we need to, and then close it again.\nTo generate the surface for our video, we are using the inbuilt MATLAB peaks command. To make things look nice in the resulting figures, we add the lines:\naxis tight manual set(gca,\u0026#39;nextplot\u0026#39;,\u0026#39;replacechildren\u0026#39;); Look at doc axis, and Prepare Figures and Axes for Graphs to understand exactly what these commands are doing.\nFinally, the loop itself:\nfor k = 1:80 surf((1 + cos(6*pi*k/80) + cos(2*pi*k/80))* 0.3333 * Z,Z) frame = getframe(gcf); writeVideo(v,frame); end We have a loop that is plotting a surface for each of 80 frames, and the surface is being manipulated slightly in each successive frame. The command getframe will save the content of the currently selected figure as a frame, which is then added to the video with the call to writeVideo, that takes as parameters the video writer object v and the frame to add to the video.\nTo alter parameters about the generated video file, including things like the frame rate or the type of compression used, look at the help files for VideoWriter.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/09_exercises_3/",
	"title": "Exercises 3",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to get you to use MATLAB to solve initial value problems. Hints and solutions are available.\nQuestion   Solve $\\frac{dy}{dx} = x^2$, subject to $y(0) = 1$.\n  Solve $\\frac{dy}{dx} = \\frac{x^2}{y}$, subject to $y(0) = 1$.\n  Solve $\\frac{dy}{dx} + \\frac{2y}{x} = x^4$, subject to $y(1) = 1$.\n  Solve $\\frac{d^2y}{dx^2} + 3\\frac{dy}{dx} - 4y = 0$, subject to $y(0) = 1$ and $y'(0) = 0$. Note you will need to reformulate this as a system of first order ODEs.\n   Expand for solution Solution Questions 1-3 are identical to the single ODE example. Question 4 is equivalent to the coupled system: $$ \\frac{dy_1}{dx} = y_2 \\,, $$ $$ \\frac{dy_2}{dx} = 4y_1 - 3y_1 \\,,$$ subject to $y_1(0)=1$ and $y_2(0)=0$ where $y_1=y$ and $y_2=z$. Therefore you can use the code from the coupled example.\nAnalytical solutions are given in a previous exercise, so you can check your answers by plotting the numerical solution against the exact solution.\n   Question Mathematical models of simple chemical or biochemical reaction mechanisms often take the form of non-linear systems of ODEs (derived using the standard chemical laws of mass action). The various reactions that make up a system often operate on very different time-scales, which leads to a \u0026lsquo;stiff\u0026rsquo; system (for more details see https://en.wikipedia.org/wiki/Stiff_equation).\nAn example is Robertson\u0026rsquo;s chemical reaction model, in which three chemical species 1, 2 and 3 react according to the following system of equations: $$ \\frac{dy_1}{dt} = -0.04y_1 + 10000y_2y_3 \\,, $$ $$ \\frac{dy_2}{dt} = 0.04y_1 - 10000y_2y_3 - 30000000y_2^2 \\,, $$ $$ \\frac{dy_3}{dt} = 30000000y_2^2 \\,. $$ With initial conditions $y_1(0) = 1$, $y_2(0) = 0$, and $y_3(0) = 0$.\n  Solve using the ode45 solver.\n  Solve using the ode15s solver, and comment on the differences between the performance of the two solvers.\n  Explain what is happening, both mathematically and chemically.\n   Expand for hint Hint Using the solution method from the ODE system example, timings can be acquired as follows:\ntic ode45(... toc     Expand for solution Solution The following code solves the Robertson reactions using ode45 and ode15s.\n% Function to solve the Robertson ODE system using ode45 and ode15s. function SolveRobertson() %% Using ode45 disp(\u0026#39;Time for ode45\u0026#39;); tic; [t,Y45] = ode45(@Robertson,[0,100],[1;0;0]); toc % Plot results subplot(1,2,1); plot(t,Y45(:,1),\u0026#39;b\u0026#39;,t,Y45(:,2),\u0026#39;r\u0026#39;,t,Y45(:,3),\u0026#39;g\u0026#39;); legend(\u0026#39;y_1 ode45\u0026#39;,\u0026#39;y_2 ode45\u0026#39;,\u0026#39;y_3 ode45\u0026#39;); %% Using ode15s disp(\u0026#39;Time for ode15s\u0026#39;); tic; [t,Y15s] = ode15s(@Robertson,[0,100],[1;0;0]); toc % Plot results subplot(1,2,2); plot(t,Y15s(:,1),\u0026#39;b\u0026#39;,t,Y15s(:,2),\u0026#39;r\u0026#39;,t,Y15s(:,3),\u0026#39;g\u0026#39;); legend(\u0026#39;y_1 ode15s\u0026#39;,\u0026#39;y_2 ode15s\u0026#39;,\u0026#39;y_3 ode15s\u0026#39;); %% Evaluate the right hand side of the system function dYdt = Robertson(t,Y) dYdt = [-0.04*Y(1) + 10000*Y(2)*Y(3); 0.04*Y(1) - 10000*Y(2)*Y(3) - 30000000*Y(2)^2; 30000000*Y(2)^2]; end end Running the code, by saving in a file named SolveRobertson.m and executing it with SolveRobertson(), yields the following output:\n\u0026gt;\u0026gt; SolveRobertson Time for ode45 Elapsed time is 1.090715 seconds. Time for ode15s Elapsed time is 0.007496 seconds. and the following plot:\nFor this particular example, ode15s is almost 150x faster than ode45.\nThe reactions are occurring on different time-scales and mathematically the problem is known to be \u0026lsquo;stiff\u0026rsquo;. Therefore, using ode15s, which is designed for such problems, is much more efficient than ode45 in this situation.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/09_exercises_4/",
	"title": "Exercises 4",
	"tags": [],
	"description": "",
	"content": " Question Verify analytically that the Fourier series of a square wave defined as:\n$$f(x) = \\left\\{ \\begin{array}{ll} -k \u0026amp; \\textrm{if}\\quad -\\pi\u0026lt;x\u0026lt;0\\,, \\\\ k \u0026amp; \\textrm{if}\\quad 0\u0026lt;x\u0026lt;\\pi\\,, \\end{array} \\right. $$\nand\n$$f(x+2\\pi) = f(x)$$\nis\n$$\\frac{4k}{\\pi}\\left( \\sin{x} + \\frac{1}{3}\\sin{3x} + \\frac{1}{5}\\sin{5x} + \\ldots \\right).$$\n Expand for soluton Solution $$a_0 = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\,dx = 0 $$ $$a_n = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\cos{nx}\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\cos{nx}\\,dx = 0\\, , \\quad \\textrm{for} \\quad n=1,2,\\ldots $$ and $$b_n = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\sin{nx}\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\sin{nx}\\,dx = \\frac{4k}{n\\pi}\\,, \\quad \\textrm{for} \\quad n=1,3,5,\\ldots $$ and\n$$b_n = 0 \\quad \\textrm{for} \\quad n = 2,4,6,\\ldots.$$\n   Question   Write MATLAB code to sum the first components of the series calculated in the question above, for increasing values of $N$, to see how the series converges.\n  The lack of convergence at the discontinuities is known as Gibbs\u0026rsquo;s phenomenon, and the mathematical explanation dates back to the beginning of the twentieth century. Quantify Gibbs\u0026rsquo;s phenomenon and give a mathematical explanation for it. (There\u0026rsquo;s a good one on Wikipedia.)\n   Expand for solution Solution   The following code will sum this series and plot the sum for $N=0,1,5,100$:\n% Plot the sum of the first N components of the Fourier series. clear close all % N=100; % Number of terms to include in series k=1; % Parameter for f % x=linspace(-pi,pi,1000); y=zeros(N+1,length(x)); % initialise the series % y(1,:)=4*k/pi*sin(x); % first term % Add on terms in the series for n=2:N y(n,:)=y(n-1,:)+4*k/(2*n-1)/pi*sin((2*n-1)*x); end % plot(x,y(1,:),x,y(5,:),x,y(10,:),x,y(100,:)); legend(\u0026#39;N=1\u0026#39;,\u0026#39;N=5\u0026#39;,\u0026#39;N=10\u0026#39;,\u0026#39;N=100\u0026#39;,\u0026#39;location\u0026#39;,\u0026#39;NorthWest\u0026#39;) The code yields the following plot\nwhich shows the convergence of the series to the square wave function $f(x)$.\n  The magnitude of the error of the Fourier series solution (the overshooting near the discontinuity) is the same as $N\\to\\infty$, but the width of the overshoot does tend to zero as $N\\to\\infty$. You can see this from the above figure.\n     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/09_simple_m_files_scripts/",
	"title": "Simple M-files: scripts",
	"tags": [],
	"description": "",
	"content": "Instead of typing the commands into the Command Window, they may be typed into a file with a .m extension, which allows commands to be built up into a high-level computer program.\nInfo Most of the time when you use MATLAB, you will write scripts, which are just text files with a .m extension, rather than typing commands directly into the Command Window.\n Opening a new M-file From the \u0026lsquo;Home\u0026rsquo; tab, click \u0026lsquo;New Script\u0026rsquo;, or, from the \u0026lsquo;Editor\u0026rsquo; tab, select \u0026lsquo;New\u0026rsquo; and then \u0026lsquo;Script\u0026rsquo;.\nThis will open a new window that is a text editor. You can also type the following command in the Command Window:\nedit to open the MATLAB editor.\nWriting an M-file In a MATLAB script, you can type exactly the commands that you type into the Command Window, but you can write and run multiple commands at once. In the text editor type the following lines of code:\nA=[1 2; 3 4] B=[5 6; 7 8] C=A+B Click on the \u0026lsquo;Save\u0026rsquo; button on the toolbar and save the file as\nmymfile.m Running the M-file Return to the Command Window and type\nmymfile This has the same output as if you had entered the three lines of the M-file in the Command Window.\nWarning You must make sure not to name your file the same as a pre-existing MATLAB function. You can use the exist command (see doc exist) to find out if your function name is being used for an existing function.\n Breaking code across multiple lines While writing M-files you will often have to write long lines of code like:\nA=2*eye(500)-diag(ones(499,1),1)-diag(ones(499,1),-1); In order to make it easier to see what the code is doing and to prevent artificial line breaks (where the editor decides where to break the code across multiple lines) you can use the following:\nA=2*eye(500) ... ; -diag(ones(499,1),1) ... ; -diag(ones(499,1),-1); The dots ... indicate that we wish to continue the current line of code on the next line of the file, when you run the file it is as if all the commands are on the same line.\nComments If you are writing lots of different M-files it is handy to insert comments into the code. Anything in the M-file preceded by a % will be ignored when the M-file is executed. For example, the following code runs exactly the same commands as the mymfile.m file we created earlier.\n%%% Code to add two matrices together %%% A=[1 2; 3 4] % the first matrix B=[5 6; 7 8] % the second matrix % The sum of the two matrices C=A+B "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/09_speeding_up_code_part_1/",
	"title": "Speeding up code: part 1",
	"tags": [],
	"description": "",
	"content": "There are various methods for speeding up your code and the Writing Fast MATLAB Code guide contains a lot of useful tips. We now list some examples of the key methods used to speed up MATLAB code: preallocating; vectorising; using inbuilt functions; and using sparse matrices.\nPreallocating Most of your calculations in MATLAB have involved manipulations of matrices and vectors, which can slow code down immensely if not used correctly. The following walkthrough will show you how to avoid these problems.\nWalkthrough MATLAB allows vectors and matrices to grow dynamically in the code.\nFor example the following code:\ntic x = 0; for k = 2:1000000 x(k) = x(k-1) + 5; end toc shows that the loop takes approximately 0.068569 seconds. If we preallocate:\ntic x = zeros(1,1000000); for k = 2:1000000 x(k) = x(k-1) + 5; end toc then the same operation takes just 0.003594 seconds, a nearly 20x speed-up. This problem was substantially worse in older versions of MATLAB, but preallocation is still recommended by MATLAB.\nYou can preallocate matrices in a similar way by using\nA=zeros(M,N); If the size of the vector is unknown, then you can use an upper limit and then crop the vector afterwards, for example\nx=zeros(1,100); % Preallocate i=1; % initialise i while x(i)\u0026lt;100 i=i+1; x(i)=i^2; end x(i+1:end)=[]; % Crop the vector x This is one of the biggest reasons for slow code and the MATLAB editor will highlight this by underlining growing vectors and matrices with orange lines, as shown in the following figure:\nVectorising MATLAB is designed to be very quick at applying operations to arrays rather than applying them many times in loops. Therefore vectors should be used when an operation needs to be applied to every element of an array. The process of converting loops for vector and matrix operations is known as vectorisation. This is shown in the following walkthrough example.\nWalkthrough Consider the three following vectors\nx=rand(100000,1); y=rand(100000,1); z=rand(100000,1); Then the following (preallocated) loop\nd=zeros(size(x)); for i=1:100 d(i) = x(i)^2 + y(i)^2 + z(i)^2; end could be replaced by the one line\nd = x.^2 + y.^2 + z.^2; MATLAB is getting much smarter at recognising loops that can be replaced with vectorised operations, so it\u0026rsquo;s likely that this specific example will be a similar speed whether you use the loop or the one line calculation. But, in general, loops should be avoided in MATLAB where possible, and use the built-in vectorised operations wherever possible.\nTo help vectorise code you can use the \u0026lsquo;find\u0026rsquo;, \u0026lsquo;any\u0026rsquo; and \u0026lsquo;all\u0026rsquo; commands.\nLook at the help files for these functions:\ndoc find doc any doc all and try the following commands:\nfind([1 2 4]\u0026gt;[5 4 1]) find([1 0 1]==1) any([1 0 0 1]) all([1 0 0 1]) Can you see how using these commands replaces hand-writing a loop together with \u0026lsquo;if\u0026rsquo; statements?\nStoring your variables as matrices and vectors will also make your code shorter and, hopefully, more readable. In addition this will enable you to make use of the vector and matrix operators (such as multiplication) in MATLAB.\nUsing inbuilt MATLAB functions MATLAB\u0026rsquo;s inbuilt functions will operate faster than code you have written yourself. The simplest example of this may be seen in calculations of the maximum and minimum. If we use the code to calculate the maximum (from the first unit), we can compare it to the inbuilt max command.\nfunction [max_x] = maximum(x) max_x=x(1); for i=1:length(x) if x(i)\u0026gt;max_x max_x=x(i); end end end This is a very simple code to calculate the maximum of a vector, but it is very difficult to speed it up without using inbuilt MATLAB functions. If we compare this to the inbuilt max function using\nx=rand(10^7,1); tic; max_x = maximum(x); toc; tic; max_x = max(x); toc; we see that our method takes about 0.019851 seconds whereas the inbuilt code takes 0.003771 seconds. Although this is difference is relatively minor in absolute terms, the inbuilt version is still about 5x faster. This is because all the low-end functions such as \u0026lsquo;max\u0026rsquo; are written in machine code and optimised by MATLAB for the system on which it is installed, so the inbuilt methods should always be faster.\nMoreover using the inbuilt commands also means you can write less code.\nSparse matrices As seen in the earlier unit \u0026lsquo;Linear algebra in MATLAB\u0026rsquo;, a matrix whose entries are mostly zero is known as \u0026lsquo;sparse\u0026rsquo;. The command:\nA=sparse(A); will convert $A$ to a sparse matrix and only the non-zero entries will be stored, reducing storage. Moreover, MATLAB has versions of most commands specifically for use with sparse matrices and vectors, and MATLAB will automatically select the optimal version. The improvements to be derived from using sparse matrices in terms of speed were shown in unit 4.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/10_boundary_value_problems/",
	"title": "Boundary value problems",
	"tags": [],
	"description": "",
	"content": "Problem definition Suppose we wish to solve the system of equations $\\frac{d\\mathbf{y}}{dx}=\\mathbf{f}(x,\\mathbf{y})$, with conditions applied at two different points $x=a$ and $x=b$.\nMore commonly, problems of this sort will be written as a higher-order (that is, a second-order) ODE with derivative boundary conditions We can reduce any such equation to a system of first-order equations, however, so we only need to consider how to solve systems of first-order equations.\nSuch problems are known as \u0026lsquo;Boundary Value Problems\u0026rsquo; (BVPs).\nFor a system to be well defined, there should be as many conditions as there are first-order equations. For example, to solve two second-order ODEs you would need four conditions, as this system would equate to one with four first-order ODEs.\nMatlab commands Suppose we wish to solve the system of $n$ equations, $\\frac{d\\mathbf{y}}{dx}=\\mathbf{f}(x,\\mathbf{y})$, with conditions applied at two different points $x=a$ and $x=b$.\nIn order to use the inbuilt MATLAB ODE solvers, you need to follow the steps below:\n  Construct a function (here called deriv) which has input arguments $x$ and $\\mathbf{y}=(y_1,\\ldots,y_n)$ and returns the value of the derivative $\\frac{d\\mathbf{y}}{dx}$, that is $\\mathbf{f}(x,\\mathbf{y})$.\n  Construct a function (here called bcs) which has input arguments $\\mathbf{y}(a)$ and $\\mathbf{y}(b)$ and returns the value of the residual for each specified boundary condition. For example to apply $y_1(a)=1$ and $y_1(b)=0$ use\nfunction res = bcs(ya,yb) res = [ ya(1) - 1 yb(1)]; To apply conditions to the other variables, $y_2$, etc. change the index to ya(2) or yb(2), for example.\n  Define the solution domain and provide an initial guess for the solution on the solution domain. Use the command\nsolinit = bvpinit([a,b],[0,0]); This defines the domain for solution as $[a,b]$, and the initial guess for the solution at the points specified in the domain as $[0,0]$. (Note that we could use a more accurate initial guess, that is define the domain using linspace(a,b,100) and then define the solution on these points.)\n  Call the ODE solver bvp4c, using the following command\nsol = bvp4c(@deriv,@bcs,solinit); The various parameters are:\n  @deriv, a handle to a function that given $x$ and $\\mathbf{y}$ returns the value of the derivative $\\frac{d\\mathbf{y}}{dx}$;\n  @bcs, a handle to a function that defines the boundary conditions;\n  solinit, the structure defining the solution\u0026rsquo;s domain and that initial guess at the solution; and\n  sol, a structure that contains the solution.\n    Plot the results, which are now stored as sol.x and sol.y.\nplot(sol.x,sol.y(1,:),\u0026#39;b-x\u0026#39;);   Walkthrough Suppose we wish to solve the following boundary value problem.\nConsider the equation $$ \\frac{d^2y}{dx^2} + y = 0 \\,. $$ subject to $y'(0) = 1$ and $y(\\pi) = 0$.\nThe exact solution is $y = \\sin(x)$.\nTo solve this numerically, we first need to reduce the second-order equation to a system of first-order equations, $$ \\frac{dy}{dx} = z \\,, $$ $$ \\frac{dz}{dx} = -y \\,. $$ with $z(0) = 1$ and $y(\\pi) = 0$.\nExample code to solve this is given by:\n% Function to solve d^2ydx^2+y = 0. function SimpleBVP() %% Set up, solve, \u0026amp; plot the BVP % Initial guess for solution on solution domain solinit = bvpinit([0,pi],[0,0]); % Solve the BVP sol = bvp4c(@deriv,@bcs,solinit); % Plot the solution plot(sol.x,sol.y(1,:),\u0026#39;b-x\u0026#39;); %% Function to evaluate the right hand side of the system function dYdx = deriv(x,Y) dYdx(1) = Y(2); dYdx(2) = -Y(1); end %% Function to evaluate the boundary values, y\u0026#39;(a)=1, y(b)=0 function res = bcs(ya,yb) res = [ ya(2) - 1 yb(1)]; end end You can run the code by saving in a file named SimpleBVP.m and executing it with SimpleBVP(). The main elements of this code are:\n  solinit = bvpinit([0,pi],[0,0]); which defines the domain for solution through $[0,\\pi]$ and the initial guess for the solution at the points specified in the domain, $[0,0]$.\n  sol = bvp4c(@deriv,@bcs,solinit); which is the call to the bvp4c solver, the various parameters are:\n  @deriv, a handle to a function that returns the value of the derivative $\\frac{dy}{dx}$ for a given $x$ and $y$;\n  @bcs is a handle to a function that defines the boundary conditions; and solinit is the structure defining the solution domain and initial guess.\n    plot(sol.x,sol.y(1,:),'b-x'); which plots the solution.\n  function dydx = deriv(x,y) which is a function that returns the value of $\\frac{d\\mathbf{y}}{dx}$ for a given $x$ and $\\mathbf{y}$ at that point (which here is the vector $[−z,y]$).\n  function res = bcs(ya,yb) which is a function which defines the boundary conditions applied at $a=0$ and $b=1$.\n  Running the code (using SimpleBVP()) yields the following plot:\nThis is plotted against the exact solution, $y=\\sin(x)$, in the next figure:\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/10_flow_control/",
	"title": "Flow control",
	"tags": [],
	"description": "",
	"content": "For loops If a collection of statements need to be executed a fixed number of times, a for loop may be used.\nWalkthrough For example, the following commands print out the integers between 1 and 10 inclusive:\nfor i=1:10 i end While loops If a collection of statements need to be executed until a stopping criteria is reached a while loop may be used.\nWalkthrough For example the following commands print out the integers between 1 and 10 inclusive:\ni=1; while ( i \u0026lt;= 10 ) i i=i+1; end Operators that may be useful when using while loops are\n == – equal to (note that this is not the same as a single ‘=’ which is used to assign variables) ~= – not equal to \u0026lt; – less than \u0026gt; – greater than \u0026lt;= – less than or equal to \u0026gt;= – greater than or equal to  If statements If a given statement only needs to be executed under a given condition, an if statement may be used.\nWalkthrough For example, the following statements print out the variable x if x is negative:\nif (x\u0026lt;0) x end "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/10_speeding_up_code_part_2/",
	"title": "Speeding up code: part 2",
	"tags": [],
	"description": "",
	"content": "Even if you have tried all the standard methods of improving your code, there are specific tools in MATLAB to help you to identify bottlenecks. The main one of these tools is the profiler.\nMATLAB profiler Often the best way to develop code is to develop a prototype that has the required functionality, and then to speed up this prototype while maintaining that functionality. A profiler is a tool that identifies how much time is spent executing each line of the code, which enables us to find problem areas and use the methods of improvement described above to speed it up.\nWalkthrough MATLAB has its own inbuilt in profiler. See \u0026lsquo;doc profile\u0026rsquo; for instructions on how to use it. The profiler can be used via the Command Window, but it is easiest to access it via the \u0026lsquo;Run and Time\u0026rsquo; button.\nDownload the file HeatEquation.m and put it in your working directory.\nFirst, run the code with parameter $N=100$ by pressing the arrow under the \u0026lsquo;Run\u0026rsquo; button, and where it says type code to run, replace the $N$ with 100. Check that it runs OK, with no errors in the Command Window.\nThen, press \u0026lsquo;Run and Time\u0026rsquo;. That should bring up the following window:\nClicking on HeatEquation (the one with the biggest blue bar) reveals the lines of code where most time was spent:\nThis indicates the areas where you can improve the code, as you will see in the exercises later.\nOther tips and tricks There are many other things that you can do to try to speed up your code. Some other assorted tips and tricks are.\n In Linux you can start MATLAB with only the command line. To do this start MATLAB using the command matlab –nodesktop You can write components of your code as external .mex files, which may be precompiled C++ and Fortran. For more details see doc mex. This kind of optimisation is suitable for loop-heavy code (that cannot be vectorised) and as a last resort for code that requires maximum speed. The Writing Fast MATLAB Code guide is an excellent source for ways to speed up MATLAB code.  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/11_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "Consider the partial differential equation $$\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2},\\qquad\\mbox{for}\\qquad 0\u0026lt;x\u0026lt;1,\\quad 0\u0026lt;t\u0026lt;0.2,$$\nwith boundary conditions $u(0,t) = u(1,t)=0$ and initial condition $u(x,0)=\\sin(\\pi x)$. This is the \u0026lsquo;Unsteady Heat Equation\u0026rsquo;, whose exact solution is given by $$u(x,t)=\\sin(\\pi x)\\exp(-\\pi^2 t).$$\nThe function HeatEquation.m solves this system using a forward Euler scheme for the temporal derivative and a second-order finite difference formula for the spatial derivative. You are not required to understand the solution method, but more details can be found in Numerical Solution of Partial Differential Equations by K. W. Morton and D. F. Mayers if you are interested.\nQuestion This code is currently very inefficient and can be improved. Using the techniques you have learned in this unit and from the suggested preliminary reading, speed up the code. You can only change the code from line 18 and you must still produce the plot and output the same error.\nThe speed of the code can be assessed by running\ntic, Error = HeatEquation(100), toc which has output\n\u0026gt;\u0026gt; tic, Error = HeatEquation(100), toc Error = 6.6559e-05 Elapsed time is 3.069019 seconds. where Error is the maximum error of the numerical solution compared to the actual solution (in both time and space). The time will be different depending on the speed of your computer and the other programs you are currently running.\nCurrently, running HeatEquation with $N=500$ intervals yields an error of 2.6626e-06 but takes many hours to run, but it should be possible to reduce this to a few seconds by improving the code.\n Expand for solution Solution The code below is an optimised version of the inefficient code provided in HeatEquation.m.\nThe things that have been changed are:\n moving the calculation of A outside the loop; saving only the current solution rather than growing matrices; using backslash instead of calculating the inverse  It is possible to solve for $N=500$ in under 3.3 seconds, and it may be possible to go faster than this by using .mex files or through improvements to the numerical solution methods.\n% Function that solves the 1d heat equation on [0,1] with zero Dirichlet % boundary conditions and initial condition u_0=sin(pi*x). % % Inputs: N - Number of points to solve on. % Outputs: MaxError - Maximum error of the numerical solution. function MaxError = FastHeatEquation(N) %% You can\u0026#39;t change this section %% nu = 0.2; % ratio of spatial to temporal step, chosen for stability dx = 1/N; % space step dt = nu*dx^2; % time step (Chosen to ensure stability) x = (0:dx:1)\u0026#39;; % grid points to solve on ue = sin(pi*x); % initial data MaxError = 0; EndTime = 0.2; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% You can change from here on in %% % Construct A outside the loop: col = ones(N-1,1); % Column vector of ones D = spdiags([col -2*col col],[-1,0,1],N-1,N-1); A = spdiags(col,0,N-1,N-1)-nu*D; % LHS matrix % u = ue(2:N); % Remove boundary values (always 0) % figure; hold on; plot(x,[0;u;0],\u0026#39;b\u0026#39;,x,ue,\u0026#39;r:\u0026#39;); drawnow; % Plot current solution for t = dt:dt:EndTime u = A\\u; % Update solution ue = sin(pi*x)*exp(-pi*pi*t); % Compute exact solution % At intervals of 0.05, plot current solution if mod(t,0.05) \u0026lt; dt plot(x,[0;u;0],\u0026#39;b\u0026#39;,x,ue,\u0026#39;r:\u0026#39;); drawnow; end MaxError = max([MaxError,max(u-ue(2:N))]); end end     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/11_exercises_4/",
	"title": "Exercises 4",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to get you to use MATLAB to solve boundary value problems. Hints and solutions are available.\nQuestion Use bvp4c to solve the following boundary value problems.\nConsider the equation $$ \\frac{d^2y}{dx^2} + 3\\frac{dy}{dx} - 4y = 0 \\,. $$\n  Solve this subject to $y(0) = 0$ and $y(1) = 1$.\n  Solve the same equation subject to $y'(0) = 0$ and $y(1) = 1$.\n   Expand for solution Solution To solve this numerically, we first need to reduce the second-order system to a system of first-order equations, $$ \\frac{dy}{dx} = z \\,, $$ $$ \\frac{dz}{dx} = 4y - 3z \\,. $$ Example code to solve this system with associated boundary conditions is given by\n% Function to solve y\u0026#39;\u0026#39;+ 3y\u0026#39; - 4y^2 = 0. function SolveBVP() %% Set up, solve, \u0026amp; plot the BVP solinit = bvpinit([0,1],[0 0]); sol = bvp4c(@deriv,@bcs,solinit); x=linspace(0,1,100); y=deval(sol,x); plot(x,y(1,:),\u0026#39;b-x\u0026#39;); xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) %% Function to evaluate the right hand side of the system function dYdx = deriv(x,Y) % dYdx(1) = Y(2); dYdx(2) = 4*Y(1)-3*Y(2); end %% Function to evaluate the boundary values function res = bcs(ya,yb) res = [ ya(1) yb(1)-1]; % res = [ ya(2) % yb(1)-1]; end end Running this code yields the following plot, which shows that both boundary conditions are satisfied:\nIn order to solve the equations with the second set of boundary conditions, replace the bcs function by the commented version. This yields the following plot.\nNote that now the derivative of $y$ is now zero at $x=0$.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/11_simple_graphics/",
	"title": "Simple graphics",
	"tags": [],
	"description": "",
	"content": "MATLAB incorporates many powerful graphic tools and can provide visualisations in two or three dimensions, and most books on MATLAB have whole chapters devoted to producing graphics.\nSingle plots We will now go through how to plot a simple function in MATLAB and save the figure to a file you can use in a report.\nWalkthrough To plot the function $\\sin(x)$ for $x$ between 0 and 10 type:\nfplot(@(x)sin(x),[0 10]) Here, the notation @(x)sin(x) is referred to in MATLAB as an anonymous function. It specifies a function that takes x and outputs sin(x).\nThis gives you the following figure on screen:\nTo label the axes and add a title type\nxlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) title(\u0026#39;y=sin(x)\u0026#39;) which updates the figure as follows:\nYou can save the figure by clicking on the \u0026lsquo;Save\u0026rsquo; icon in the top left corner of the screen. This will save the figure as a .fig file which can only be opened in MATLAB.\nIf you want to save the file in a format that you can include in a report, select the \u0026lsquo;Save As\u0026rsquo; item in the \u0026lsquo;File\u0026rsquo; menu. You can select the type of file to save as in the \u0026lsquo;Save as type:\u0026rsquo; drop-down menu. The best file type to save the figure as are .eps if you are using LaTeX, a .png or .tiff if you are using something like Microsoft Word, or .svg if you are writing for the web.\nThe figure produced is given below:\nThere are also command line commands such as\nprint ExampleFigure.png –dpng which will print the currently selected figure to the file ExampleFigure.png. The second command –dpng selects the type of file in which the figure will be saved - try doing this now. For more options see\ndoc print To close the figure use the close command.\nMultiple plots You can also include multiple plots in the same figure, using the procedure covered in the following walkthrough.\nWalkthrough To plot two data-sets y1 and y2 against x on the same diagram, use the method shown below.\nx=[1 2 3 4 5 6]; y1=[1 4 9 16 25 36]; y2=[6 5 4 3 2 1]; plot(x,y1, \u0026#39;-\u0026#39;,x,y2,\u0026#39;--\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39; ) legend(\u0026#39;y1\u0026#39;,\u0026#39;y2\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) The statement plot(x,y1,'-',x,y2,'--') tells MATLAB to plot y1 against x as a solid line, and to plot y2 against x as a broken line. Note the use of legend to label the lines and the position of the legend.\nYou could also use the command hold on. To do this see doc hold for examples.\nThe text size on the axes and other properties of the figure can easily be altered. There are a number of options available under \u0026lsquo;View\u0026rsquo; including \u0026lsquo;Plot Edit Toolbar\u0026rsquo; and \u0026lsquo;Figure Palette\u0026rsquo; which bring up a number of options as shown here:\nIt is very important that the axes and labels on a figure are readable when you use the figure in a report, and you can use the plot tools to ensure this. To change the size of the text, just click on the text you wish to resize and you can then edit the font. All other properties of the figure can be changed using the plot tools.\nSubfigures You can also make multiple subplots in the same figure using the subplot command. Look it up now in the help files before continuing.\nWalkthrough To plot $sin(x)$ and $cos(x)$ in separate plots contained in the same figure we use the following commands:\nsubplot(1,2,1); fplot(@(x)sin(x),[0 10]); title(\u0026#39;y=sin(x)\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); subplot(1,2,2); fplot(@(x)cos(x),[0 10],\u0026#39;r\u0026#39;); title(\u0026#39;y=cos(x)\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); The statement subplot(1,2,1) tells MATLAB to create a grid of 1 by 2 subfigures within the main figure, and the last number indicates in which subfigure to put the next command. You can change these numbers to get a larger number of subfigures. You can add labels and titles to each of these subfigures in the usual way.\nThese commands result in the following figure:\nThe text size on the axes and other properties of the figure can easily be altered by selecting the options from the \u0026lsquo;View\u0026rsquo; menu, as with a single plot.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/12_plotting_3d_data/",
	"title": "Plotting 3D data",
	"tags": [],
	"description": "",
	"content": "MATLAB can also plot functions and data in 3D. The following commands are used to plot in 3D:\nplot3 surf mesh contour Before you continue, look at the help files for those commands.\nThe following walkthrough is an example of producing a plot of a 3D function.\nWalkthrough First create a mesh on which to plot the surface\nx = linspace(0,20,100); y = linspace(0,10,100); [X,Y] = meshgrid(x,y); Then define a surface by defining a \u0026lsquo;z-value\u0026rsquo; for each point on the mesh:\nZ=sin(X).*sin(Y); To view the surface in 3D use the commands:\nsurf(X,Y,Z) which gives:\nmesh(X,Y,Z) which gives:\ncontour(X,Y,Z) which gives:\nplot3(X,Y,Z) which gives:\nMany of the same tools and commands that worked in 2D plots (legend, title, etc) also work in 3D.\nTo close all figures at once you can use the close all command.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/13_functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": "A particularly useful feature of MATLAB is the ability to define functions.\nWalkthrough The syntax for defining the function $y=x^2$ is as follows:\nfunction [y] = xsquared(x) y = x^2;  Info  The [y] indicates the variables that will be returned from the function: there may be multiple, e.g. [y1, y2]. The (x) indicates the parameters that are passed to the function: there may be multiple, e.g. (x1, x2).   Type these commands into an M-file called xsquared.m and save this file. Now type:\nxsquared(5) and then\nd=7; xsquared(d) Note that MATLAB also allows you to apply functions to arrays. To do this with the power function we modify the above by placing a '.' before the '^' in the above:\nfunction [y] = xsquared(x) y = x.^2; Now type on the command line\ne=[4,5,6]; xsquared(e) "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/14_exercises/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "The unit closes with a few simple exercises for you to test the skills you have learned throughout the unit.\nQuestion Problem 1: Hint based problem\n Write functions to calculate the maximum and minimum of an array of numbers, without using the commands max or min. Your functions should take in a vector and return values for the maximum and minimum.   Expand for hint Hint The following if statement will find the maximum between max_x and x(i):\nif x(i)\u0026gt;max_x max_x=x(i); end    Combine the functions from part 1. to make one function that returns both the maximum and the minimum. See doc function for help on how to return multiple values.   Expand for solution Solution   The following code will calculate the maximum of an array passed to it:\nfunction [max_x] = maximum(x) max_x=x(1); for i=1:length(x) if x(i)\u0026gt;max_x max_x=x(i); end end The following code will calculate the minimum of an array passed to it.\nfunction [min_x] = minimum(x) min_x=x(1); for i=1:length(x) if x(i)\u0026lt;min_x min_x=x(i); end end To use these, save the above a .m files with the appropriate names, and run the commands:\nminimum(x) maximum(x) where x is a vector.\n  The following code will calculate the minimum and the maximum of an array passed to it:\nfunction [min_x,max_x] = minmax(x) min_x=x(1); max_x=x(1); for i=1:length(x) if x(i)\u0026lt;min_x min_x=x(i); end if x(i)\u0026gt;max_x max_x=x(i); end end To call the function, save the above as minmax.m, and run:\n[minimum,maximum] = minmax(x)      Question Problem 2: Hint based problem\n Plot the functions $y=x^3$ and $y=x^5$, on the interval $[-2,\\,2]$, on the same graph. Where are the intersections of the curves?   Expand for hint Hint You may want to create the following vectors:\nx=linspace(-2,2,100); y1=x.^3; and use the plot functionality you learned in this unit.\n  Add a title and legend to the graph, label the axes, and save the figure as a .png file.   Expand for solution Solution   Intersections occur at $(x,\\,y)=(−1,\\,−1),(0,\\,0),(1,\\,1)$. The following commands plot the curves:\nx=linspace(-2,2,100); y1=x.^3; y2=x.^5; plot(x,y1,\u0026#39;-\u0026#39;,x,y2,\u0026#39;--\u0026#39;);   The following commands will add a label and legend to the figure:\nlegend(\u0026#39;y=x^3\u0026#39;,\u0026#39;y=x^5\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); You can save the file by using \u0026lsquo;Save As\u0026rsquo; in the \u0026lsquo;File\u0026rsquo; menu or by using the following command.\nprint ExampleFigure.png -dpng      "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]