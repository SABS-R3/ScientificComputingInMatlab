[
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/",
	"title": "Course introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 0 Course introduction "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/",
	"title": "Basic introduction to MATLAB",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basic introduction to MATLAB "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/",
	"title": "Data and image analysis",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Data and image analysis "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/",
	"title": "Basic calculus",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Basic calculus "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/",
	"title": "Linear algebra",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Linear algebra "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/",
	"title": "Solving ODEs",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Solving ODEs Warning Chapter under construction. Original course available here.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/",
	"title": "Software engineering",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Software engineering Warning Chapter under construction. Original course available here.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Scientific Computing in MATLAB An online course from the DTC at the University of Oxford This is a new version of the existing course, and is still under construction.\nThe existing course is available here: http://www.dtc.ox.ac.uk/online-learning/matlab/\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/01_course_overview/",
	"title": "Course Overview",
	"tags": [],
	"description": "",
	"content": "Welcome to \u0026lsquo;Scientific Computing in MATLAB\u0026rsquo;. We are delighted you have chosen this course and hope it will meet your expectations.\nIn this preliminary unit we shall be looking at:\n communications managing your learning activities.  If you are already familiar with online study, you will be able to skip through these sessions quickly and get onto the real stuff. If you are not, it may answer a few of your questions. If you have any remaining questions contact your tutor who will be happy to help.\nIf you have questions relating to the academic content or learning, please contact your course tutor, who will introduce him-or herself to you via email.\nMathematical prerequisites The course is a mathematically based one and we assume that you have studied mathematics to A level or equivalent. You should be familiar with the ideas of vectors, matrices, differentiation and integration along with basic probability and statistics. There will be reminders of the key mathematical ideas where they are used, along with appropriate references, but we will not be explaining everything from scratch.\nRequired reading There is no required reading for this course, which is relatively self-contained. References are given throughout the course where you can find more information on particular topics, many of which are online resources or help files. There are however certain places where no appropriate online sources are available, so we have given references to appropriate books.\nRequired software For this course you will need access to a computer with the MATLAB software installed. Section 0.3 contains details on how to get MATLAB. If you already have access to MATLAB then you can skip this section.\nUnits This course is divided into six units, each of which is designed to take between a few hours and a few days to cover, depending on your prior programming and mathematics experience. The units are as follows:\n Unit 1: Basic introduction to MATLAB Unit 2: Data analysis, image analysis and basic statistics in MATLAB Unit 3: Basic calculus in MATLAB Unit 4: Linear algebra in MATLAB Unit 5: Solving ODEs in MATLAB Unit 6: Software engineering and scientific computing  Each unit consists of:\n an introduction giving you an outline of the topic covered in the unit and its learning objectives information about the topic you are studying, giving you the context within which your reading should make sense a number of activities, some of which are pen and paper exercises, and the majority of which are MATLAB exercises (and both types contain hints and solutions) recommended resources for further exploration.  Learning expectations Depending on how the course you are taking is structured, you may be working full-time on this course, or only for a few hours a week. You will find that a lot of that time is spent working on the exercises in MATLAB and – we hope – discussing the issues with your fellow students. This will help you to share ideas and experiences and learn from others as you progress through the course.\nIn undertaking this course, you are committing yourself to:\n regularly reading the course materials working through all activities, which is especially important as this is the main mechanism for learning on this course completing the final assignment.  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives In this introductory unit you will learn the basics of MATLAB, from how to start MATLAB through to how to use it to write simple code and to use basic graphic capabilities of MATLAB. The aim of this unit is for you to acquire a familiarity with MATLAB and to learn a few basic commands.\nWhen you see things written in typewriter font as in this for example, you should type these commands into the MATLAB command window. his unit consists mostly of walkthroughs which introduce you to the commands that you will use throughout the course; be sure to enter these commands into MATLAB as you go through the walkthroughs. If you come across a command that you don\u0026rsquo;t know, use the inbuilt MATLAB help files (which we will explain how to use below) to find out what it does.\nThis course was developed using MATLAB on Microsoft Windows, but MATLAB is the same regardless of the operating system you are using. Some aspects of the appearance may vary between operating systems, but all functionality should be the same.\nReading list There is no specific reading list for this unit but the following resources may be useful.\n the MATLAB help system (found by typing \u0026lsquo;doc\u0026rsquo; on the command line), which is explained in one of the first screens the online MATLAB documentation The book MATLAB Primer, by Timothy A. Davis and Kermit Sigmon  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives Data analysis and statistics are the cornerstones of most quantitative disciplines. MATLAB has many inbuilt commands for calculating statistics from large data-sets. In this unit we will look at some of MATLAB’s inbuilt statistical commands and also use MATLAB to perform some common data analysis techniques. By the end of the unit you should be able to perform simple statistical analyses on data-sets and have gained an understanding of how to use MATLAB to generate various types of random samples. We will also learn how to read data (including images) into MATLAB, how to display these data, how to process these data and how to write the data back to a file.\nReading list In order to understand the material in this unit you should know some probability and statistics. We assume that you have an A level understanding of probability and statistics.\nThe following are suitable introductory reference sources on probability and statistics. Where needed, references for more advanced material will be given.\n Any A level or undergraduate introduction to probability or statistics The statistics wikibook Chapter 24 (in the ninth edition) of Advanced Engineering Mathematics by Erwin Kreyszig. (This is a huge book but you should be able to find a copy in your library.)  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Learning objectives The solution of systems of linear equations forms the basis of many techniques in applied mathematics and statistics, so numerical linear algebra forms perhaps the most important set of tools in scientific programming. MATLAB has been developed specifically to handle matrix and vector operations (hence its name – a portmanteau of \u0026lsquo;matrix\u0026rsquo; and \u0026lsquo;laboratory\u0026rsquo;). It has some particularly efficient and effective inbuilt commands to enable the easy manipulation of matrices and vectors, and very straightforward solutions of linear systems (and hence of nonlinear systems).\nThe aim of this unit is to show you how to use the inbuilt functionality to manipulate vectors and matrices and to solve the linear system $A\\mathbf{x}=\\mathbf{b}$. More importantly, you will see which methods are appropriate in which situation.\nThe unit begins with a walkthrough of the basics of matrix manipulation in MATLAB which will give you a good introduction to its inbuilt functionality. There are some exercises at the end to test your understanding. The second half of the unit is concerned with the solution of the linear system $A\\mathbf{x}=\\mathbf{b}$, and will require you to use the basic commands you learned in the first half in order to solve some typical linear systems that arise in solving partial differential equations. (Note: You will not need to understand where the linear systems come from, but they are from a \u0026lsquo;real world problem\u0026rsquo; so they will give you an insight into the power of MATLAB.)\nThis unit assumes you are already familiar with manipulating vectors and matrices, and with concepts such as eigenvalues and determinants. This material is covered at A level and in the first year of undergraduate mathematics degrees, so any introductory linear algebra book will contain the material. Some examples are listed below.\nReading list There are many undergraduate texts on linear algebra, which are mainly theoretical. One that is particularly recommended is Linear Algebra and its Applications by Gilbert Strang. Again, all ideas will be introduced where they are needed, and references will be given.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/01_introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/01_introduction_and_definitions/",
	"title": "Introduction and definitions",
	"tags": [],
	"description": "",
	"content": "Learning objectives The purpose of this unit is to use MATLAB to carry out many of the analytical mathematical techniques that you know. We will look at traditional methods of numerical differentiation and integration as well as root-finding algorithms. Also included is a section on Fourier series which allow discontinuous functions to be approximated by sums of continuous functions. The aim of the unit is to show you how to use MATLAB to undertake all these operations and also to give you practice in creating MATLAB functions.\nReading list The best book for descriptions of the numerical methods used here is Advanced Engineering Mathematics by Erwin Kreyszig.\nThere will be appropriate references wherever new numerical ideas are introduced.\nIf you do not know the underlying ideas of differentiation and integration then you can find details in:\n any A level textbook any first-year undergraduate calculus textbook the Calculus Wikibook  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/01_introduction_and_definitions/",
	"title": "Introduction and definitions",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/02_analytical_methods_1st_order/",
	"title": "Analytical methods: 1st order",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/02_course_activities/",
	"title": "Course Activities",
	"tags": [],
	"description": "",
	"content": "The main teaching mechanism on this course is through activities and exercises. Each unit is composed of a number of such activities which will not only introduce the material to you but also enable you to demonstrate your understanding (or to express your lack of understanding – something you should never be afraid to do).\nRegular activities and resources There are several kinds of activity that you will be asked to complete while on this course. Some of these will be ongoing throughout the course, whereas others will relate to the topic of a particular week. Activity types include:\nReading: Doing this lets you explore the content of the course. Usually you will receive guidance about things you should be considering as you do the reading to help you get the most from it.\nIndividual activities: These will help you to consolidate the learning from your reading and further explore the ideas in the course. Much of the work you undertake on your own will feed into your assignments.\nThe activities are broken up into the following two categories:\nWalkthroughs: In each of these, you will be taken through an application of MATLAB. You should type all commands given into the MATLAB command window as you work your way through the activity.\nProblems: You will be given a problem to solve using MATLAB (and, very occasionally, pen and paper). This will require the creation of a figure or the development of an appropriate MATLAB function. Hints and solutions will be given.\nThe work you do for many of the exercises on this course will be directly useful in the assignment, which will therefore be much less onerous if you have completed the activities as you go along.\nCode and Mathematics Code will be written in typewriter font, this for example, and you should type these commands into the MATLAB command window when you see them, to see what they do.\nLonger code blocks will appear like this:\nb=ones(500,1); tic, x1=A\\b; toc tic, x2=B\\b; toc Mathematics will be presented in maths font, i.e. $\\Psi(\\mathbf{r},t)$, and longer equations may appear on on their own line, such as:\n$$i\\hbar\\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) = \\left [ \\frac{-\\hbar^2}{2\\mu}\\nabla^2 + V(\\mathbf{r},t)\\right ] \\Psi(\\mathbf{r},t).$$\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/02_formatting_code_part_1/",
	"title": "Formatting code: part 1",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/02_numerical_differentiation/",
	"title": "Numerical differentiation",
	"tags": [],
	"description": "",
	"content": "You should already be familiar with the idea of analytical differentiation and be able to differentiate simple functions like $y=x^n$ and $y=sin(x)$. If you don’t know how to do this, look it up now in any A level textbook or the relevant section of the Calculus Wikibook.\nSometimes functions are highly non-linear and a closed form for the derivative may be difficult to calculate. For example\n$$y=x^{\\ln x}$$\nAlternatively, $y$ can be defined as the solution to an equation, so we can not calculate a closed form for $y=f(x)$ to which the traditional rules of differentiation may be applied. In such cases we may calculate a numerical approximation for the derivative using the following difference formulae.\nSummary of mathematics used Suppose $y=f(x)$. Let the points $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced over the interval $\\left[a,b\\right]$, and let $h=\\frac{1}{N}\\left(x_N−x_0\\right)=x_{i+1}−x_i$. Now let $y_i=f(x_i)$.\n The forward difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}-y_i}{h}$$ The backward difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_i−y_{i−1}}{h}$$ The central difference approximation to the first derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}−y_{i−1}}{2h}$$ An approximation to the second derivative at $x=x_i$ is given by: $$\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2}$$  Where $h$ is assumed to be small, the smaller $h$ is, the better the approximation becomes. The derivation of these forms is undertaken in the next exercise.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/02_simple_summary_statistics/",
	"title": "Simple summary statistics",
	"tags": [],
	"description": "",
	"content": "Useful MATLAB commands There are many inbuilt MATLAB commands for calculating statistical properties of data. Some of them are listed below:\n max - returns the maximum value of an array. min – returns the minimum value of an array. mean – returns the mean (average) value of the array. median – returns the median value of an array. mode – returns the mode value of an array. std – returns the standard deviation of an array. var – returns the variance of an array. hist – plots the values in the array as a histogram. sort – sorts the elements of the array in ascending order. sum – returns the sum of all the elements of the array. rand – generates uniformly distributed random numbers. randn – generates normally distributed random numbers with mean 0 and variance 1.  The following activities will help you use these basic commands.\nQuestion Look at the MATLAB help files (doc max etc) for each of the above commands and apply them all (except rand and randn) to the following vector:\nx = [3 -47 -6 -29 37 -22 -7 12 -7 -18 -53 -12 34 12 -35 28 -5 22 4 -70 -32 47 -6 -19 8 17 -22 9 -39 -21]; What happens if you apply these to a matrix? For example, try applying them to the following matrix:\nrandn(100,5)  Expand for solution Solution The operations yield the following:\n max(x) : 47 min(x) : -70 mean(x) : -7.2333 median(x) : -6.5 mode(x) : -22 std(x) : 27.6314 var(x) : 763.4954 hist(x) :  sort(x) : \u0026gt;\u0026gt; sort(x) ans = Columns 1 through 17 -70 -53 -47 -39 -35 -32 -29 -22 -22 -21 -19 -18 -12 -7 -7 -6 -6 Columns 18 through 30 -5 3 4 8 9 12 12 17 22 28 34 37 47  sum(x) : -217  Applying them to matrices will perform the operation on columns. For example,\nsum(rand(10,5)) will yield a row vector with five elements which are the sums of each column.\nMoreover\nhist(randn(1000,5)) will yield the following multiple histogram with each colour representing a column of the matrix.\n   Question Generate a series of random samples of data of increasing size drawn from (i) a uniform distribution and (ii) a normal distribution. Draw histograms of each sample and, by calculating the mean and standard deviation of each sample, verify that these two statistics tend to their theoretical limit values as the size of the sample increases.\n Expand for hint Hint The mean and variance for a uniform $U(0,1)$ distribution are $\\mu=0.5 \\,,\\, \\sigma=1/\\sqrt{12}$\nThe mean and variance for a normal $N(0,1)$ distribution are $\\mu=0 \\,,\\, \\sigma=1$.\n   Expand for solution Solution To generate the data for 1,000 samples use\nX=rand(1000,1); Y=randn(1000,1); To plot the histograms use\nfigure; hist(X); title(\u0026#39;Data from Uniform\u0026#39;); figure; hist(Y); title(\u0026#39;Data from Normal\u0026#39;); To calculate the mean and standard deviation use\nmean(X) std(X) mean(Y) std(Y) which should be close to the theoretical values of $\\mu=0.5 \\,,\\, \\sigma=1/\\sqrt{12}$ for the $U(0,1)$ data and $\\mu=0 \\,,\\, \\sigma=1$ for the $N(0,1)$ data. These values should get closer as the sample size increases.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/02_vectors_and_matrices/",
	"title": "Vectors and matrices",
	"tags": [],
	"description": "",
	"content": "The following walkthrough exercises contain a number of activities designed to teach you the basics of using MATLAB for working with vectors and matrices.\nBasic vector and matrix manipulation You have already learned many basic matrix manipulation commands in the first unit. This walkthrough provides a quick review of this material with a few new commands added.\nWalkthrough Let\nx=[1,2,3] y=[2,4,6]\u0026#39; z=[2;4;6] Enter the following commands on the command line and make sure you understand what they do. If you are unsure use the MATLAB help files.\nx*y y*x y*z y.*z sum(x) prod(y)  Question Do all of the operations work? If one doesn\u0026rsquo;t then why not.\n Expand for solution Solution y*z will not work as this is multiplying two column vectors together.\n   Now let\nA=[1,2,3;4,5,6;1,3,2] Enter the following commands on the command line and make sure you understand what they do. If you are unsure use the MATLAB help files.\nB=A\u0026#39; A*y A*B det(A) inv(B) B*inv(B) trace(A) A(1,2) A(:,2) A(1,:) A(2,2:3) A([2,1,3],:) A^2 A.^2 sum(A,1) prod(A,2) C=[A,z] ones(5,1) ones(5) zeros(1,5) Now clear the workspace\nclear Size of vectors and matrices You also learned lots of commands for finding the size of vectors and matrices.\nWalkthrough Let\nA=randn(512); b=randn(512,1); Enter the following commands on the command line and make sure you understand what they do. If you are unsure, use the MATLAB help files.\nlength(A) size(A) size(b) b(end) b(end-5:end) Now clear the workspace\nclear Parts of vectors and matrices We often wish to look at certain parts of matrices: the diagonal entries, for example. The following will introduce some commands that will allow you to select specific entries.\nWalkthrough Let\nA= randn(10); Enter the following commands on the command line and use spy to visualise the non-zero entries of the resulting matrices. What do you see?\nMake sure you understand what all the commands do. If you are unsure, use the MATLAB help files.\ntriu(A) tril(A) diag(A) diag(A,2) diag(diag(A)) Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/02_what_is_matlab/",
	"title": "What is MATLAB?",
	"tags": [],
	"description": "",
	"content": "MATLAB is:\n a calculator; a powerful graphics tool; and a high-level programming language including a large number of mathematical tools.  "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/03_analytical_methods_2nd_order/",
	"title": "Analytical methods: 2nd order",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/03_eigenvalues_and_eigenvectors/",
	"title": "Eigenvalues and eigenvectors",
	"tags": [],
	"description": "",
	"content": "Key properties of square matrices are their eigenvalues and eigenvectors, which enable them to be written in a simpler form, through a process known as eigenvalue decomposition. This is useful for performing mathematical and numerical analysis of matrices in order to identify their key features. A similar process is available for non-square matrices, known as singular value decomposition (SVD). (Note that SVD also exists for square matrices.) There are inbuilt tools within MATLAB that may be used to perform both of these decompositions.\nInfo For more details on the theory of eigenvalues and singular value decomposition see Linear Algebra and its Applications by Gilbert Strang, or the following web pages:\n http://mathworld.wolfram.com/Eigenvalue.html http://mathworld.wolfram.com/Eigenvector.html http://mathworld.wolfram.com/EigenDecomposition.html http://mathworld.wolfram.com/SingularValueDecomposition.html   We now look at the commands in MATLAB that enable us to calculate these decompositions.\nWalkthrough Consider the square matrix\nA=randn(10); The following commands calculate the eigenvalues and eigenvectors of the matrix (enter the commands):\ne=eig(A); [V,D]=eig(A); Print e !nc, V !nc and D !nc.\nEvaluate the following:\nA*V - V*D  Question What does this give you? Why is this? Use the MATLAB help files to work out what V !nc and D !nc are.\n Expand for solution Solution This gives you a matrix that is zero to machine precision (that is, all their entries are less than $10^{−12}$). This is because the eigenvalue decomposition of $A$ is $A=VDV^{-1}$, where $V$ is a matrix whose columns are the eigenvectors of $A$ and $D$ is a diagonal matrix containing the eigenvalues of $A$.\n   Now consider the non-square matrix:\nA=randn(10,5); The following commands calculate the singular value decomposition (SVD) of the matrix:\n[U,S,V]=svd(A); Evaluate the following\nA - U*S*V\u0026#39;  Question What does this give you? Why is this?\n Expand for solution Solution Again, this gives you a matrix that is zero to machine precision (all entries are less than $10^{−12}$). This is because the singular value decomposition of $A$ is $A=USV^{T}$, where $U$ and $V$ are square orthogonal matrices of different sizes and $S$ is a matrix of the same size as $A$ whose diagonal entries are the singular values of $A$, with extra rows or columns of zeros depending on the size of $A$.\n   Info Note that the command [U,S,V]=svd(A,0) calculates the economic version of the SVD. What is this?\n Expand for solution Solution The economic form just removes the zero rows/columns from $S$.\n   Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/03_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to give you a familiarity with numerical differentiation. Hints and solutions are available.\nQuestion Do the following problem with pen and paper. Using the Taylor series expansion of the form: $$y(t)=y(a)+(t−a)y'(a)+(t−a)^2y''(a)+(t−a)^3\\frac{y'''(a)}{3!}+\\ldots$$\n Derive the forward difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_i}{h}$$ Derive the backward difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_i−y_{i−1}}{h}$$ Derive the central difference formula, $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_{i−1}}{2h}$$ Optional: If you are feeling adventurous derive the second derivative approximation, $$\\frac{d^2y}{dx^2}\\approx\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2}$$  Hint: you will need to include more terms in your Taylor expansion.\n Expand for solution Solution   Let $t=x_{i+1}$ and $a=x_i$. Then the first two terms of the Taylor expansion give: $$y_{i+1} \\approx y_i+hy'(x_i)$$ Rearranging this gives: $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_i}{h},$$ the forward difference rule.\n  Similarly, using $t=x_{i−1}$ and $a=x_i$ gives, on rearranging: $$\\frac{dy}{dx}\\approx\\frac{y_i−y_{i−1}}{h},$$ the backward difference rule.\n  Adding the two previous formulae together and dividing by 2 gives: $$\\frac{dy}{dx}\\approx\\frac{y_{i+1}−y_{i−1}}{2h},$$ the central difference rule.\n  Finally, if we include the third term in the expansions in 1. and 2. then we get: $$y_{i+1} \\approx y_i+hy'(x_i)+\\frac{h^2}{2}y''(x_i)$$ and $$y_{i−1} \\approx y_i−hy'(x_i)+\\frac{h^2}{2}y''(x_i).$$ Adding these together and rearranging gives: $$\\frac{d^2y}{dx^2}\\approx\\frac{y_{i+1}−2y_i+y_{i−1}}{h^2},$$ the second derivative approximation.\n     Question Let $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced points over the interval $[−3,3]$. Let $h=6/N$, so that $x_{i+1}−x_i=h$. Let $f(x)=x^4$, and so $f'(x)=4x^3$ and $f''(x)=12x^2$.\nBegin by choosing $N=10$:\n Approximate the first derivative at the points $x_0,x_1,x_2,...,x_{N−1}$ using forward differences.   Expand for hint Hint The following code calculates the derivative and produces the following plot:\nN=10; h=6/N; x=linspace(-3,3,N+1); y=x.*x.*x.*x; yprime=4*x.*x.*x; % for i=1:N forwarddiff(i) = (y(i+1)-y(i))/h; end % plot(x,yprime,x(1:N),forwarddiff) legend(\u0026#39;True\u0026#39;,\u0026#39;Forward\u0026#39;)   Approximate the first derivative at the points $x_1,x_2,x_3,\\ldots,x_N$ using backward differences.   Expand for hint Hint Modify the code from part 1.\n   Approximate the first derivative at the points $x_1,x_2,x_3,\\ldots,x_{N−1}$ using central differences.\n  Approximate the second derivative at the points $x_1,x_2,x_3,\\ldots,x_{N−1}$.\n  Plot your approximations and the true values of $f'(x)$ and $f''(x)$ on the same graphs (one for $f'(x)$ and one for $f''(x)$).\n  What is the maximum absolute error for each approximation?\n   Expand for solution Solution The code below will calculate all the approximations and plot them on the same graph as the exact solutions.\nclear all close all N=10; % The number of intervals to use h=6/N; % the step size x=linspace(-3,3,N+1); % %% Calculate the exact solutions y=x.*x.*x.*x; yprime=4*x.*x.*x; yprimeprime=12*x.*x; % %% Calculate the approximations forwarddiff(1) = (y(2)-y(1))/h for i=2:N forwarddiff(i) = (y(i+1)-y(i))/h; backwarddiff(i-1) = (y(i)-y(i-1))/(h); centraldiff(i-1)=(y(i+1)-y(i-1))/(2*h); secondderiv(i-1)=(y(i-1)-2*y(i)+y(i+1))/(h*h); end backwarddiff(N) = (y(N+1)-y(N))/h % %% Evaluate the maximum error for each approximation MaxErrorInForwardDifference=max(abs(yprime(1:N)-forwarddiff)) MaxErrorInBackwardDifference=max(abs(yprime(2:N+1)-backwarddiff)) MaxErrorInCentralDifference=max(abs(yprime(2:N)-centraldiff)) MaxErrorInSecondDerivative=max(abs(yprimeprime(2:N)-secondderiv)) % %% Plot the approximations witht the actual derivatives plot(x,yprime,x(1:N),forwarddiff,x(2:N+1),backwarddiff,x(2:N),centraldiff) title(\u0026#39;First Derivative\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) legend(\u0026#39;True\u0026#39;,\u0026#39;Forward\u0026#39;,\u0026#39;Back\u0026#39;,\u0026#39;Central\u0026#39;) % figure plot(x,yprimeprime,x(2:N),secondderiv) title(\u0026#39;Second Derivative\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) legend(\u0026#39;True\u0026#39;,\u0026#39;Approx\u0026#39;) The maximum error for each approximation is:\n Forward Difference = 28.2960 Backward Difference = 28.2960 Central Difference = 3.4560 Second Derivative = 0.7200  The following plots are generated:    Repeat for $N=20$ and $N=40$.\ni) In each case, how big does $N$ need to be so that the maximum absolute error of the derivative at each discrete point is less than 0.01?\nii) Comment on how the maximum absolute error for each scheme decreases as $N$ is doubled.\n   Expand for solution Solution The maximum errors for different values of $N$ can be calculated by modifying the code from a) above and are given in the table below.\n   N Forward Difference Backward Difference Central Difference Second Derivative     10 28.2960 28.2960 3.4560 0.7200   20 15.1470 15.1470 0.9720 0.1800   40 7.8344 7.8344 0.2565 0.0450    To get a maximum absolute error of less than 0.01 we require:\n $N=323$ for forward and backward differences; $N=208$ for central differences; $N=86$ for the second derivative.  For forward and backward differences, the error roughly halves as $N$ is doubled.\nFor central differences and second derivatives, the error is divided by roughly 4 as $N$ is doubled.\nIn mathematical terms, the first two are \u0026lsquo;first order\u0026rsquo; and the second two are \u0026lsquo;second order\u0026rsquo; as $N$ increases. Don\u0026rsquo;t worry if you don\u0026rsquo;t know what it means.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/03_formatting_code_part_2/",
	"title": "Formatting code: part 2",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_0_introduction/03_getting_matlab/",
	"title": "Getting MATLAB",
	"tags": [],
	"description": "",
	"content": "A pre-requisite for the course is to have the program MATLAB installed on your computer. You will only need the basic version of MATLAB for this course. As you will discover there are many toolboxes are available which extend the functionality of MATLAB but these are not needed for this course. In this section we will get MATLAB set up on your computer.\nChecking for MATLAB If you are using a departmental computer then MATLAB may already have been installed for you. The following will show you if it is installed or not.\nIf you have the following icon on your desktop (or in your start menu) then you already have MATLAB installed: In Linux, try typing matlab into the command line to see if you have MATLAB installed. If it is installed then the MATLAB Command window will open.\nIf MATLAB is installed on your computer then you can ignore the rest of this section. However, if you don\u0026rsquo;t have MATLAB installed on your machine then contact your College or Department\u0026rsquo;s IT support officers and they will be able to help.\nIf you are using a personal computer for this course then there are a few ways of getting MATLAB.\nDownloading MATLAB from inside Oxford University If you are an Oxford University student then MATLAB is available from IT Services under a university-wide student licence, details of which can be found at the following link:\nhttps://help.it.ox.ac.uk/sls/matlab\nYou will need to use your Single Sign-On to get access to MATLAB.\nUsing MATLAB online It is possible to use MATLAB in your web browser by going to:\nhttps://matlab.mathworks.com/\nThis still requires you to have an account with MathWorks, which you can obtain via the University of Oxford by following the instructions above. While using MATLAB in the browser may be sufficient for this course, it is preferable to have MATLAB installed on the machine you will be using. You will get better performance, have access to more features, have have your files stored locally.\nPurchasing MATLAB directly from MathWorks If you don\u0026rsquo;t have an Oxford University Single Sign-On, and your IT support cannot setup MATLAB for you, then you can also purchase MATLAB directly from MathWorks, at https://www.mathworks.com/.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/03_linear_regression/",
	"title": "Linear regression",
	"tags": [],
	"description": "",
	"content": "When presented with a data-set, one way to analyse the data is to perform linear regression. The most common form of linear regression is known as ‘least squares fitting’, whose aim is to fit a polynomial curve to the data such that the sum of the squares of the distance from the data points to the line is minimised.\nInfo If you have never come across this before then look it up. The first link has a particularly good description.\nThe theory of least squares fitting can be found in the following:\n Wolfram MathWorld Chapter 7 of The Statistical Sleuth by Ramsey and Schafer. Chapter 25 (in the ninth edition) of Advanced Engineering Mathematics by Erwin Kreyszig.   The following activity will lead you through generating some experimental data adding artificial noise and then performing least squares estimation to try to elucidate the underlying model parameters.\nQuestion Often mathematical models of experimental or physiological systems are developed to form the basis of a measurement technique. For example, it is not possible to measure cardiac output directly, but we may be able to infer it from analysis of a mathematical model of respiratory gas exchange. For such models we are often solving an inverse problem of parameter estimation (the cardiac output), where the parameter of interest is embedded (somewhere) within the mathematical model. In these circumstances, it is often advisable to introduce simulated experimental error into the system to test the robustness of the recovery procedure. The following is one of the simplest possible examples, where the parameters form part of a linear model, but more commonly the parameters would be embedded within a system of ODEs or PDEs or in some complex stochastic process.\n Generate and plot the data ($x$ and $y$ values) for a simple straight line of the form $y=ax+b$ where $a=2$ and $b=1$ are constants and $x\\in\\left[0,1\\right]$. You should calculate the value of $y$ at 21 evenly spaced points between 0 and 1, (that is, at $x=0,0.5,0.1,\\ldots,1$).   Expand for solution Solution The following will generate and plot the line.\n% Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); plot(x,y,\u0026#39;b.-\u0026#39;) which yields the following figure.\n  Generate random errors from a normal distribution, with zero mean $\\mu$ and standard deviation $\\sigma=0.1$, using MATLAB’s inbuilt commands, and add these to each of the $y$ coordinates in 1. Plot these values as points on the same graph as in 1. What happens if $\\mu$ is non-zero?   Expand for solution Solution The following will generate noise, add it to the line and plot it with red crosses.\n% Simulate random noise around this line noise=randn(size(y)); % Generating numbers from a N(0,1) dist stdnoise=0.1; % Standard deviation of the noise ynoisy=y+stdnoise*noise; % Make the noisy data hold on; % note this puts the plots on the same figure plot(x,ynoisy,\u0026#39;rx\u0026#39;) which yields the following figure.\nNote: your noise will be different, so the red crosses may be in slightly different places, but they will still be close to the original line.\n  Using the command polyfit perform a linear regression through the data generated in 2, and plot the regression line on the same plot.   Expand for solution Solution The command\np=polyfit(x,ynoisy,1); will calculate the coefficients of the regression line $y=\\alpha{x}+\\beta$ (to the line $y=ax+b$), where the coefficients are in descending order, so the constant term is the second entry. This is a general function, and the third variable specifies the order of the regression line. For example:\np=polyfit(x,ynoisy,2); would calculate the quadratic regression coefficients.\nTherefore, the following code will calculate the regression line and plot it on the same figure in red.\np=polyfit(x,ynoisy,1); z=p(1)*x + p(2); plot(x,z,\u0026#39;r\u0026#39;); which yields the following figure.\n  Repeat 2 and 3 for differing values of the standard deviation, from $\\sigma=0$, to $\\sigma=1$, in steps of 0.2, and plot the regression lines on the same graph. You should use a loop to do this.   Expand for solution Solution The following code will generate and plot these lines.\nclear close all % Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); % i=1; for stdnoise=0:0.2:1 % Generate N(0,1) random errors and add to the data with % a suitably scaled standard deviation noise=randn(size(y)); ynoisy(:,i)=y+stdnoise*noise; % Fit a straight line through the noisy data using Polyfit p(:,i)=polyfit(x,ynoisy(:,i),1); z(:,i)=p(1,i)*x+p(2,i); i=i+1; end % plot(x,z); legend(\u0026#39;0.0\u0026#39;,\u0026#39;0.2\u0026#39;,\u0026#39;0.4\u0026#39;,\u0026#39;0.6\u0026#39;,\u0026#39;0.8\u0026#39;,\u0026#39;1.0\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;); hold on plot(x,ynoisy,\u0026#39;.\u0026#39;); This yields the following figure.\n  For a suitable value of the standard deviation ($\\sigma=0.1$), repeat 2 and 3 1,000 times to investigate the statistical properties of the regression coefficients. To do this you should calculate the mean and standard deviation of the regression coefficients and compare them to the theoretical values of $\\mu=1 \\,,\\, \\sigma\\approx0.042$ for $a$, and $\\mu=2 \\,,\\, \\sigma\\approx0.071$ for $b$. The estimators should also be normally distributed. You do not need to know how these were calculated, but note that the estimators are unbiased, as the mean values of the estimators of the parameters are the parameters themselves.   Expand for solution Solution The following code will generate the means and standard deviations of the regression coefficients for 1,000 sets of random noise.\nclear close all % Generate the initial straight line data x=(0:0.05:1)\u0026#39;; y=(1+2*x); % % Calculate the Regression Coefficients for 1000 sets of noise. n=1000; for i=1:n % Generate N(0,1) random errors and add to the data with % a suitably scaled standard deviation noise(:,i)=randn(size(y)); stdnoise=0.1; ynoisy(:,i)=y+stdnoise*noise(:,i); % Fit a straight line through the noisy data using Polyfit p(:,i)=polyfit(x,ynoisy(:,i),1); end % % Look at the distributions of a and b b=p(1,:); % The first row of the matrix p a=p(2,:); % The second row of the matrix p % abar=mean(a) % Calculates the mean bbar=mean(b) % sda=std(a) % Calculates the standard deviation sdb=std(b) % % Plot Histograms of the coefficients figure(1) hist(a,30) figure(2) hist(b,30) The regression coefficients for $a$ have the following distribution\nWith mean $\\mu\\approx1$ and variance $\\sigma\\approx0.04$\nThe regression coefficients for $b$ have the following distribution\nWith mean $\\mu\\approx2$ and variance $sigma\\approx0.07$\n  Explain why the above can be used to simulate the effects of random experimental error.   Expand for solution Solution Experimental error will manifest as noise added to the results, so we can apply this method to hope to reveal the underlying model parameters.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/03_starting_matlab/",
	"title": "Starting MATLAB",
	"tags": [],
	"description": "",
	"content": "Windows  Expand for Windows instructions  In the File Explorer, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. To start MATLAB click on the \u0026lsquo;MATLAB\u0026rsquo; icon, and change the \u0026lsquo;Current Directory\u0026rsquo; to the one you just created. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   macOS  Expand for macOS instructions  In Finder, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. To start MATLAB click on the \u0026lsquo;MATLAB\u0026rsquo; icon, and change the \u0026lsquo;Current Directory\u0026rsquo; to the one you just created. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   Linux  Expand for Linux instructions   Open a terminal and type\nmkdir MatlabCourse cd MatlabCourse to make a directory and switch to it.\n  From within the directory you just created, type\nmatlab \u0026amp; A MATLAB window should now open. Any files created and saved will now be saved within this directory. Note that the \u0026lsquo;\u0026amp;\u0026rsquo; will free the MATLAB window from the terminal; otherwise, if you close the terminal you close MATLAB.\n  You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;. Note that you can use the mkdir command from within the MATLAB command window.\n   Online  Expand for web browser instructions  Go to https://matlab.mathworks.com/. Log in with your MathWorks account. In the \u0026lsquo;Current Folder\u0026rsquo; panel, right-click and select \u0026lsquo;New\u0026rsquo; then \u0026lsquo;Folder\u0026rsquo;, and call this new folder \u0026lsquo;MatlabCourse\u0026rsquo;. Double-click to enter that folder, which will set it as the current working directory. You may wish to create some appropriately named sub-directories to store separately the files from each unit of the course, for example \u0026lsquo;Unit1\u0026rsquo;.   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/04_basic_data_and_image_processing/",
	"title": "Basic data and image processing",
	"tags": [],
	"description": "",
	"content": "MATLAB has many powerful tools to read in files and manipulate data, and we will use this functionality here to read in some data and image files to undertake some basic processing.\nThere are many MATLAB commands that are used to read in data from files and write data to files, for example\n load save imread imwrite  Info Before you continue, take a look at the help files for these commands.\n Loading and saving data files In the following example we will load in data from one file and write out the data to a different file.\nWalkthrough Download the Data1.txt to the current working directory.\nTo load in data from the file \u0026lsquo;Data1.txt\u0026rsquo; we use the load command\nload Data1.txt which creates the variable Data1.txt which is a $10000\\times1$ vector (seen by using the whos command).\nAlternatively, you could load the file by using the following\ndata = load(\u0026#39;Data1.txt\u0026#39;); which allows you to specify the variable name. If you want to load a file in a different directory, then you need to use the second command as you can pass the file location as a string. If, for example, you were storing your data in a different directory (in the current working directory) called \u0026lsquo;Data\u0026rsquo;, you could use the command\ndata = load(\u0026#39;Data/Data1.txt\u0026#39;); To save data to a file you use the save command, which works in a similar way. The following command will save the variable data as a file \u0026lsquo;TestSave.txt\u0026rsquo; in plain text as specified by the –ascii option.\nsave \u0026#39;TestSave.txt\u0026#39; data -ascii Loading and saving the whole workspace You can also use save and load to save all the variables in your workspace as a .mat !nc file. Note that this file can only be read by MATLAB, unlike the .txt !nc files we made in the previous example.\nWalkthrough We begin with an empty workspace\nclear and define some variables\nx=rand(10); y=rand(10,1); whos To save all these variables we use the command\nsave AllVariables.mat; Now if we clear all the variables\nclear; whos you can see the workspace is now empty. The command\nload AllVariables.mat; will load back all the saved variables, as can be seen by typing\nwhos You can also load image files using the \u0026lsquo;imread\u0026rsquo; command as shown in the following example.\nLoading and saving images Walkthrough Download the file TestImage.png to the current working directory.\nThis is the image you are saving:\nThe following command will load the image into MATLAB and store it as a matrix in which each entry is a number between 0 and 255 that represents the intensity of that pixel. Note that this is a black-and-white image so there is only one intensity value for each pixel. If the image were in colour then there would be three such matrices (one for each base colour).\nA=imread(\u0026#39;TestImage.png\u0026#39;); You can view the image in MATLAB by typing the command\nimage(A) Suppose we had made some modifications to the image, for example by cropping the image\nA(:,[1:18, 114:end])=[]; image(A); The matrix A !nc could be saved as an image by using the command\nimwrite(A,\u0026#39;TestCroppedImage.png\u0026#39;); which produces a file \u0026lsquo;TestCroppedImage.png\u0026rsquo; which looks like the following figure\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/04_formatting_code_part_3/",
	"title": "Formatting code: part 3",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/04_numerical_integration/",
	"title": "Numerical integration",
	"tags": [],
	"description": "",
	"content": "You should already be familiar with analytic integration, as both the inverse of differentiation and a means of finding the area under a curve. If you are unsure about this, look it up now in any A level textbook or the relevant section of the Calculus Wikibook.\nFor most functions that you will come across in mathematical modelling, it will not be possible to undertake the integration analytically, and you will have to resort to numerical methods. The following explains two numerical methods for approximating integrals: the Trapezium rule, and Simpson\u0026rsquo;s rule.\nSummary of mathematics used Suppose $y=f(x)$. Let the points $x_0,x_1,x_2,\\ldots,x_N$ be equally spaced points on the interval $[a,b]$, and let $h=\\frac{1}{N}(x_N−x_0)=x_{i+}1−x_i$. Now let $y_i=f(x_i)$. The Trapezium rule for approximating integrals is:\n$$\\int_a^b f(x) \\,dx \\approx h\\left( \\frac{1}{2}y_0+y_1+y_2+\\ldots+y_{N_1}+\\frac{1}{2}y_N \\right).$$\nThis is equivalent to breaking up the area under the curve into a series of trapezia and calculating their areas, as shown in the following figure, where $y_i=f(x_i)$. The figure is from Wikipedia, unmodified, shared under the CC BY-SA 3.0 license.\nAssuming that $N$ is even, Simpson\u0026rsquo;s rule for approximating integrals is\n$$\\int_a^b f(x) \\,dx \\approx \\frac{h}{3}\\left( y_0 + 4\\left( y_1+y_3+\\ldots+y_{N-1} \\right) + 2\\left( y_2+y_4+\\ldots+y_{N-2} + y_N \\right)\\right). $$\nThis is derived in a similar way to the Trapezium rule, but by approximating the function by a quadratic curve on each interval, rather than the linear curve used by the Trapezium rule.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/04_reducing_higher_order_odes/",
	"title": "Reducing higher order ODEs",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/04_sparse_matrices/",
	"title": "Sparse matrices",
	"tags": [],
	"description": "",
	"content": "The numerical solution of differential equations often results in what is known as a \u0026lsquo;sparse linear\u0026rsquo; system. A matrix is \u0026lsquo;sparse\u0026rsquo; if most of its entries are zero, and most of the MATLAB functions you have used so far have versions that are specially optimised for sparse matrices, which can speed up your code immensely. The details of this speeding-up will be discussed further in the later unit \u0026lsquo;Software engineering\u0026rsquo;, but we introduce sparse matrices here as they will be used in exercises later in this unit.\nThe following will give you an introduction to the uses of sparse matrices.\nWalkthrough Create the matrix A !nc using the following commands:\nA=2*eye(5000)-diag(ones(4999,1),1)-diag(ones(4999,1),-1); Run the following commands to investigate the structure of A !nc:\nA(1:5,1:5) nnz(A) spy(A) spy(A(1:10,1:10))  Question What is the structure of A !nc?\n Expand for solution Solution A !nc is \u0026lsquo;tri-diagonal\u0026rsquo;, with 2 on the diagonal and −1 on the adjacent diagonals. Therefore, A !nc has $5000+(2\\times 4999)=14998$ non-zero entries, as found using nnz(A).\n   Calculate the inverse of A !nc.\nNote The inverse of A !nc is not sparse. This is true in general.\n Ai=inv(A); spy(abs(Ai)\u0026gt;1) spy(abs(Ai)\u0026gt;5) spy(abs(Ai)\u0026gt;10) spy(abs(Ai)\u0026gt;100) Calculate how long it takes to calculate $A^2$.\nInfo You can use the commands tic and toc to record elapsed time in MATLAB.\n tic; A*A; toc Create the matrix B !nc using the following commands. Note that A !nc and B !nc have the same non-zero entries:\nB=spdiags(ones(5000,1)*[-1,2,-1],[-1,0,1],5000,5000); The command spdiags creates a sparse matrix with the entries from the vector (passed as the first variable) on the diagonal indicated by the second variable. These variables can be passed individually or in groups as in the above example. The final two variables represent the size of the matrix. Look at the MATLAB help files for more information on spdiags.\nLook at the structure of B !nc:\nB(1:5,1:5) full(B(1:5,1:5)) nnz(B)  Question Using the command whos, look at how the matrices A !nc and B !nc are stored. Which uses less memory?\n Expand for solution Solution \u0026gt;\u0026gt; whos A Name Size Bytes Class Attributes A 500x500 2000000 double \u0026gt;\u0026gt; whos B Name Size Bytes Class Attributes B 500x500 27976 double sparse So A !nc used 2000000 bytes, and B !nc only used 27976 bytes, saving about 98.6% of the space.\n   Question Calculate how long it takes to calculate $B^2$:\ntic; B*B; toc Which is quicker, $A^2$ or $B^2$?\n Expand for solution Solution \u0026gt;\u0026gt; tic; A*A; toc Elapsed time is 0.768850 seconds. \u0026gt;\u0026gt; tic; B*B; toc Elapsed time is 0.013921 seconds. Calculating $B^2$ should be faster, and the proportion that it is faster should increase with the size of the matrix.\n   Question Now compare the \\ operator\nb=ones(5000,1); tic; x1=A\\b; toc tic; x2=B\\b; toc Which is quicker, A\\b or B\\b?\n Expand for solution Solution \u0026gt;\u0026gt; b=ones(5000,1); tic; x1=A\\b; toc tic; x2=B\\b; toc Elapsed time is 0.268863 seconds. Elapsed time is 0.000719 seconds. Calculating B\\b should be faster, and the proportion that it is faster should increase with the size of the matrix.\n   Finally, you can also convert matrices from full to sparse using the following command\nA=sparse(A); Using the command whos, check that A !nc is now sparse and uses the same memory as B !nc.\nNow clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/04_using_matlab_as_a_calculator/",
	"title": "Using MATLAB as a calculator",
	"tags": [],
	"description": "",
	"content": "The first thing we will use MATLAB for is a calculator.\nMATLAB uses the standard computer symbols for addition ('+ !nc'), subtraction ('- !nc'), multiplication ('* !nc') and division ('/ !nc'). Brackets are also used (if required) to indicate which operations are to be performed first.\nFor example, to evaluate $3 + 4\\left(1 + \\frac{6}{3}\\right)$ type the following in the Command Window:\n3+4*(1+6/3) and you get the answer 15. Your Command Window should look just like:\n\u0026gt;\u0026gt; 3+4*(1+6/3) ans = 15 Suppose we wished to set the variable x !nc equal to $3 + 4\\left(1 + \\frac{6}{3}\\right)$. Then we would type\nx=3+4*(1+6/3) and get the answer x = 15 !nc. In long calculations it is often unnecessary for the value of x !nc to be output to the screen. If we wanted to calculate x !nc but not output the answer to the screen we would end the line with a semicolon\nx=3+4*(1+6/3); The value of x !nc may now, if desired, be printed out by typing\nx To evaluate a power we use the \u0026lsquo;^ !nc\u0026rsquo; symbol. For example, to evaluate $3^4$ type\n3^4 Finally, you can clear the variable x !nc by typing\nclear Now typing\nx shows that the variable x !nc has been deleted:\n\u0026gt;\u0026gt; x Unrecognized function or variable \u0026#39;x\u0026#39;. "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_2_data_and_image_analysis/05_exercises/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "This unit closes with a few simple exercises for you to test the skills you have learned.\nQuestion   Download the files Data1.txt and Data2.txt to the current working directory and load them into MATLAB.\n  Using the statistical tools you learned earlier, try to identify what the data could be from.\n   Expand for hint Hint Plot a histogram of the two data-sets and calculate their means and standard deviations. You should be able to recognise an underlying probability distribution.\n   Expand for solution Solution You can load the files with the command\ndataset1 = load(\u0026#39;Data1.txt\u0026#39;); dataset2 = load(\u0026#39;Data2.txt\u0026#39;); and you can plot the histograms of both datasets using\nsubplot(1,2,1); hist(dataset1); title(\u0026#39;Data1\u0026#39;); subplot(1,2,2); hist(dataset2); title(\u0026#39;Data2\u0026#39;); which yields the plots below.\nIt is clear that the first data-set is from a normal distribution and the mean and standard deviation are found by using\nmean(dataset1) std(dataset1) mean = 175.3321 !nc and std=10.0953 !nc\nFor the second data-set it is not clear what the distribution is, as there is a relatively low number of data points, but it is still drawn from a normal distribution, whose mean and standard deviation are\nmean = 192.0019 !nc and std = 5.2121 !nc\nThe data are simulated height data. The first dataset represents heights of 10,000 men in the UK population, while the second represents the heights of 50 Olympic rowers, so the average height is larger in the second group than in the normal population.\nCode which brings all this together is given below.\nclear; close all; % dataset1 = load(\u0026#39;Data1.txt\u0026#39;); dataset2 = load(\u0026#39;Data2.txt\u0026#39;); % % plot the data as histograms subplot(1,2,1); hist(dataset1); title(\u0026#39;Data1\u0026#39;); subplot(1,2,2); hist(dataset2); title(\u0026#39;Data2\u0026#39;); % % calculate the mean and standard deviation of the data mean(dataset1) std(dataset1) mean(dataset2) std(dataset2)     Question   Download the image file TestImage.png to the current working directory and load it into MATLAB.\n  Perform \u0026lsquo;thresholding\u0026rsquo; on the image to remove the noise within it. Thresholding is an image analysis technique designed to remove noise from image to pick out its features, in this case by adjusting the intensity to 255 for any pixel in which it is already over 125, and to 0 for any pixel in which it is already below 125.\n  Save the resulting image to file.\n   Expand for hint Hint Use imread !nc and imwrite !nc to load and save the image.\nOnce the image is loaded in, you can treat it like a traditional matrix so you can perform operations such as\nfind(A\u0026gt;125) which will give you all the entries of A !nc that are greater than 125, and use this to set them all to 255.\n   Expand for solution Solution Code that loads the image and performs the thresholding is given below.\nclear; close all; % % Load image TestImage = imread(\u0026#39;TestImage.png\u0026#39;); % % Threshold image as instructed in question TestImage(TestImage \u0026gt; 125) = 255; TestImage(TestImage \u0026lt; 125) = 0; % % Save thresholded image imwrite(TestImage,\u0026#39;ThresholdedImage.png\u0026#39;); The original image is given first and the thresholded image is below, as you can see the noise is removed.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/05_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": "The following exercise will allow you to practise what you have learned so far in this unit.\nLet $A$ be a sparse symmetric positive definite matrix of dimension $(N-1)^2\\times (N-1)^2$ entered in MATLAB (for a given $N$) by the function buildA !nc as follows:\nfunction A=buildA(N) dx=1/N; nvar=(N-1)^2; e1= ones(nvar,1); e2=e1; e2( 1:N-1:nvar)=0; e3=e1; e3(N-1:N-1:nvar)=0; A=spdiags([-e1 4*e1 -e1],-(N-1):N-1:N-1,nvar,nvar)... +spdiags([-e3 -e2], -1: 2 : 1,nvar,nvar); A=A/dx^2; end We will consider manipulation of the matrix $A$, which will be used again in later exercises as the solution to the linear system containing this $A$. This corresponds to a finite difference solution to Poisson\u0026rsquo;s equation:\n$$-\\nabla^2u=f$$\non the unit square with zero Dirichlet boundary conditions.\nQuestion   Copy the function buildA !nc above into a new file buildA.m !nc in your current working directory.\n  Set $N=4$ and produce a spy plot of the matrix $A$. How many non-zero diagonals are there? How many non-zero entries are there?\n  What is the determinant of $A$ when $N=4$?\n  When $N=4$, which entries of $A^{-1}$ are greater than 0.02?\n  For $N=4$, check that $A$ is symmetric by producing a spy plot of $A-A^T$: if $A$ is symmetric there should be no non-zero entries. Check that $A$ is positive definite by looking at its eigenvalues: they should all be strictly positive.\n   Expand for solution Solution  To create the spy plot of the matrix $A$, use the MATLAB function spy(A). From this we see that there are five non-zero diagonals. Using nnz(A) we see that there are 33 non-zero entries.   When $N=4$, the MATLAB command det(A) gives the determinant as 6.8961e+15.\n  Letting B=inv(A), the command [i,j]=find(B\u0026gt;0.02) tells us that the entries (2,2), (4,4), (5,5), (6,6) and (8,8) are greater than 0.02.\n  The spy plot spy(A-A') shows no non-zero entries. Likewise, A-A' yields All zero sparse: 9×9 !nc. Both tell us that $A$ is symmetric.\nThe command e=eigs(A,9) tells us the eigenvalues are:\n\u0026gt;\u0026gt; e=eigs(A,9) e = 109.2548 86.6274 86.6274 64.0000 64.0000 64.0000 41.3726 41.3726 18.7452 and, hence, are all strictly greater than zero.\n  Note Here, by default, eigs(A) only gives a subset of the eigenvalues, but we can force MATLAB to calculate all eigenvalues by specifying the number that we want: hence, eigs(A,9).\nAn $N\\times N$ matrix will always have $N$ eigenvalues, although some may be repeated, as is the case here.\n    "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/05_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/05_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "This set of exercises is designed to give you familiarity with numerical integration. Hints and solutions are available.\nQuestion Evaluate $\\int_{-1}^{1} x^4 \\,dx$ using:\n  the Trapezium rule with 10 equal-sized intervals,\n  Simpson’s rule with 10 equal-sized intervals.\n  In each case, how many uniformly sized intervals do you need for the absolute error in the answer to be less than 0.0001?\n Expand for solution Solution The following code calculates the Trapezium rule and Simpson’s rule approximations for $N=10$.\nclear all % N=10; % Number of intervals h=2/N; % The size of each interval x=linspace(-1,1,N+1); y=x.*x.*x.*x; % Defining the function % % Firstly we apply the Trapezium rule: % TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:N TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(N+1); TrapeziumIntegral=TrapeziumIntegral*h % % Now we apply Simpson’s rule: % SimpsonIntegral=y(1); % Initialise % for i=1:N/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:N/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(N+1); SimpsonIntegral=SimpsonIntegral*h/3 The true answer is $\\left[ \\frac{x^5}{5} \\right]_{-1}^{1} = 0.4.$\nTo get the answer within 0.0001 of the true value, we require $N=164$ for the Trapezium rule and $N=16$ for Simpson’s rule. MATLAB code to calculate the $N$ required to get the integral to the required accuracy is given below:\nclear all format long % % Now look for required N for Trapezium rule % TargetError=0.0001; TrapeziumError=1; % initialise error Ntrap=10; % initial Ntrap ExactIntegral = 0.4; % while (TrapeziumError\u0026gt;TargetError) Ntrap=Ntrap+1; % Number of intervals h=2/Ntrap; % The size of each interval x=linspace(-1,1,Ntrap+1); y=x.*x.*x.*x; % Defining the function % % Now we apply the Trapezium rule: TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:Ntrap TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(Ntrap+1); TrapeziumIntegral=TrapeziumIntegral*h; % TrapeziumError = abs(TrapeziumIntegral-ExactIntegral); end % Ntrap TrapeziumError % % Now look for required N for Simpson’s rule % TargetError=0.0001; SimpsonError=1; % initialise error Nsimp=10; % initial Nsimp ExactIntegral = 0.4; % while (SimpsonError\u0026gt;TargetError) Nsimp=Nsimp+2; % Number of intervals so even h=2/Nsimp; % The size of each interval x=linspace(-1,1,Nsimp+1); y=x.*x.*x.*x; % Defining the function % % Now we apply Simpson’s rule: SimpsonIntegral=y(1); % Initialise % for i=1:Nsimp/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:Nsimp/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(Nsimp+1); SimpsonIntegral=SimpsonIntegral*h/3; % SimpsonError = abs(SimpsonIntegral-ExactIntegral); end % Nsimp SimpsonError     Question   Repeat the previous question for $\\int_0^1 \\left( e^{-1000x}+x \\right) \\,dx.$\n  Can you suggest a more sensible way to choose the discrete points instead of using uniformly spaced points?\n   Expand for solution Solution  The true answer is $\\left[ \\frac{-e^{-1000x}}{1000} + \\frac{x^2}{2}\\right]_0^1 = \\frac{1-e^{-1000}}{1000} + \\frac{1}{2} \\approx 0.501.$  To get an answer within 0.0001 of true value, we require $N=904$ for the Trapezium rule and $N=426$ for Simpson’s rule. The MATLAB code for Problem 3 can be modified for this question and is given below.\nclear all format long % Now look for required N for Trapezium rule % TargetError=0.0001; TrapeziumError=1; % initialise error Ntrap=10; % initial Ntrap ExactIntegral = (1-exp(-1000))/1000+0.5; % while (TrapeziumError\u0026gt;TargetError) Ntrap=Ntrap+1; % Number of intervals h=1/Ntrap; % The size of each interval x=linspace(0,1,Ntrap+1); y=exp(-1000*x)+x; % Defining the function % % Now we apply the Trapezium rule: TrapeziumIntegral=0.5*y(1); % Initialising 0.5*y0 % % We now loop over the elements y1…yN for i=2:Ntrap TrapeziumIntegral=TrapeziumIntegral+y(i); end % % Lastly, we need to add 0.5*yN (which corresponds to the (N+1)th % entry of the vector y) and multiply by the interval size, h % TrapeziumIntegral=TrapeziumIntegral+0.5*y(Ntrap+1); TrapeziumIntegral=TrapeziumIntegral*h; % TrapeziumError = abs(TrapeziumIntegral-ExactIntegral); end % Ntrap TrapeziumError % % Now look for required N for Simpson’s rule % TargetError=0.0001; SimpsonError=1; % initialise error Nsimp=10; % initial Nsimp ExactIntegral = (1-exp(-1000))/1000+0.5; % while (SimpsonError\u0026gt;TargetError) Nsimp=Nsimp+2; % Number of intervals so even h=1/Nsimp; % The size of each interval x=linspace(0,1,Nsimp+1); y=exp(-1000*x)+x; % Defining the function % % Now we apply Simpson’s rule: SimpsonIntegral=y(1); % Initialise % for i=1:Nsimp/2 SimpsonIntegral=SimpsonIntegral+4*y(2*i); end % for i=1:Nsimp/2-1 SimpsonIntegral=SimpsonIntegral+2*y(2*i+1); end % % Lastly, we add the last value and multiply by h/3 SimpsonIntegral=SimpsonIntegral+y(Nsimp+1); SimpsonIntegral=SimpsonIntegral*h/3; % SimpsonError = abs(SimpsonIntegral-ExactIntegral); end % Nsimp SimpsonError In order to improve accuracy, a non-uniform distribution of the $x_i$, with a higher density close to the origin, could be used.     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/05_guis_part_1/",
	"title": "GUIs: part 1",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/05_using_the_inbuilt_help/",
	"title": "Using the inbuilt help",
	"tags": [],
	"description": "",
	"content": "The help facility within MATLAB is very extensive. You will be using the help files throughout this course to find out what a new function does when you first come across it.\nIf you know the name of the function in which you are interested, you can type help FunctionName.\nFor instance, typing help fft will display\n\u0026gt;\u0026gt; help fft fft Discrete Fourier transform. fft(X) is the discrete Fourier transform (DFT) of vector X. For matrices, the fft operation is applied to each column. For N-D arrays, the fft operation operates on the first non-singleton dimension. ... Instead, you can open the more extensive documentation pages by typing doc FunctionName. For instance, typing doc fft will open the following window:\nThe only real drawback is that you need to know not only that something is there but also what it is called. Fortunately, most of the MATLAB commands have sensible names and there is inbuilt search functionality for the graphical help.\nYou can just load the graphical help browser where you can search for the function you need by typing doc, which brings up the following window:\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/06_guis_part_2/",
	"title": "GUIs: part 2",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/06_numerical_methods/",
	"title": "Numerical methods",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/06_solution_of_nonlinear_equations/",
	"title": "Solution of nonlinear equations",
	"tags": [],
	"description": "",
	"content": "We very often need to find the zero of a complex non-linear function when working with mathematical modelling problems, perhaps most frequently when we wish to find the value (or values) of $x$ such that two functions, say $f$ and $g$, are equal, that is $f(x)=g(x)$. This problem is equivalent to letting $y(x)=f(x)−g(x)$ and determining the value(s) of $x$ such that $y(x)=0$.\nHere we will use the numerical methods of interval bisection and Newton\u0026rsquo;s method (also known as Newton–Raphson) to find the zero of a function.\nSummary of mathematics used Interval bisection Suppose $f(x)$ is a continuous function, such that $f(a)\u0026lt;0$ and $f(b)\u0026gt;0$. An approximation to $f(x)=0$ may be calculated using the following algorithm:\n  Let $c = \\frac{(a+b)}{2}$\n  If $f(c)\u0026lt;0$, then the root lies in the interval $[c,b]$, so let $a=c$. If $f(c)\u0026gt;0$, then the root lies in the interval $[a,c]$, so let $b=c$. If $f(c)=0$ then the root is at $x=c$\n  Repeat this process until you have a root to the desired accuracy.\n  Question Do this problem with pen and paper.\nModify this algorithm for the case $f(a)\u0026gt;0$ and $f(b)\u0026lt;0$\n Expand for solution Solution   Let $c = \\frac{(a+b)}{2}$\n  If $f(c)\u0026lt;0$, then the root lies in the interval $[c,b]$, so let $a=c$. If $f(c)\u0026gt;0$, then the root lies in the interval $[a,c]$, so let $b=c$. If $f(c)=0$ then the root is at $x=c$.\n  Repeat this process until you have a root to the desired accuracy.\n     Newton-Raphson Suppose that $f(x)$ is a continuous function. An approximation to $f(x)=0$ may be calculated using the following algorithm:\n  Start with an initial guess $x_0$.\n  Calculate the next solution using: $$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$$\n  Repeat step 2 until you have the root to the required accuracy.\n  For more details on Newton–Raphson see: https://mathworld.wolfram.com/NewtonsMethod.html\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/06_solving_axb_basic/",
	"title": "Solving $Ax=b$: basic",
	"tags": [],
	"description": "",
	"content": "Much of linear algebra is concerned with solving the linear system $Ax=b$. MATLAB has many inbuilt functions to do this, and in this section you will learn how to use them.\nThe two easiest methods for calculating the solution to $Ax=b$ are to calculate the inverse, using inv or the \\ (backslash) operator. The former calculates the inverse explicitly while the latter calculates the solution to $Ax=b$ using an appropriate numerical technique, such as Gaussian elimination. If you are not familiar with Gaussian elimination, see any textbook on linear algebra, or the Wolfram Mathworld page.\nWe will now go through an example of using these two solution methods.\nWalkthrough Let\nA=randn(4096); b=randn(4096,1);  Question Solve $Ax=b$ using both of the methods described above and time how long each method takes:\ntic, x1=inv(A)*b; toc tic, x2=A\\b; toc plot(x1-x2) What is the error between the two solutions and which was quicker?\n Expand for solution Solution Depending on your computer, the \\ backslash operator will probably take less than half the time of explicitly calculating the inverse. Plotting x1-x2 !nc\nshows that the maximum error is roughly 1e-12, which can be confirmed by calculating max(abs(x1-x2)) which, for this random linear system, yields 1.0467e-12.\nYour answer will be different due to the randomness of A !nc and b !nc.\n   Now clear the workspace\nclear The following code calculates the efficiency of the two solution methods for progressively larger systems. (Note that this plots the data using a log vs. log plot (help loglog) as the values grow exponentially.)\n% we will perform 20 repeats on 12 problem sizes num_repeats=20; num_problems=12; % % 2, 4, 8, 16, ..., 4096 problem_sizes=2.^(1:num_problems); % % pre-allocate two matrices to store the times in times_inv=zeros(num_repeats,num_problems); times_slash=zeros(num_repeats,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); for repeat=1:num_repeats % create the random matrix A and vector b A=randn(problem_size); b=randn(problem_size,1); % time the two methods of solving Ax=b tic; x1=inv(A)*b; times_inv(repeat,problem)=toc; tic; x2=A\\b; times_slash(repeat,problem)=toc; end end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,mean(times_inv),\u0026#39;rx\u0026#39;,... problem_sizes,mean(times_slash),\u0026#39;bo\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to solve a matrix problem using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) First, read the code above and make sure you understand what it does. Next, run the code. It may take up to a minute, depending on your computer.\nQuestion What does the resulting plot tell you about the speeds of the two methods?\n Expand for solution Solution Running the above code produces the following figure:\nThis shows that, once the linear system is large enough (about 16x16), then backslash is always faster than calculating the inverse. Because the matrices are generated randomly, the code averages over a number of repeats to try and understand the average behaviour.\nThis is an artificial problem, but later you will see how an approach to a \u0026lsquo;real world\u0026rsquo; problem is affected by the choice of solution methods.\nCan you think of any reasons that 4x4 systems might be quicker to solve than 2x2 systems? Why might the inverse be faster than backslash for 4x4 systems?\n   Now clear the workspace\nclear "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/06_vectors_and_matrices_part_1/",
	"title": "Vectors and matrices: part 1",
	"tags": [],
	"description": "",
	"content": " Info The main data structures in MATLAB are vectors and matrices. If you have never heard of these before, then look them up in:\n an A-level textbook, on the Wolfram MathWorld pages, or on Wikipedia  before you continue.\n Vectors Vectors in MATLAB are $n\\times 1$ or $1\\times n$ arrays of numbers.\nWalkthrough Suppose the vector $u$ is given by $u=(1\\;4\\;9)$. This may be entered into MATLAB in either of the following ways:\n  By entering each entry of the matrix individually.\nu(1)=1; u(2)=4; u(3)=9; Note that u(1) !nc corresponds to the first entry of u !nc, etc.\n  By typing the entries inside square brackets separated by spaces:\nu=[1 4 9];   The transpose of u !nc may be printed by typing u'.\nSuppose the vector $v$ is given by: $$v=\\begin{pmatrix}4\\\\5\\\\6\\end{pmatrix}$$\nThis may be entered by typing:\nv = [4;5;6]; Inside the square brackets the semicolon denotes a new row.\nNote Vectors are sometimes referred to as arrays. This may be confusing so always look at the dimensions of the array to check the type.\n The length of a vector v !nc can be found by using the command length(v), which here gives:\n\u0026gt;\u0026gt; length(v) ans = 3 The size of a vector v !nc can be found by using the command size(v), which here gives:\n\u0026gt;\u0026gt; size(v) ans = 3 1 This tells us that v !nc has 3 rows and 1 column, and thus allows us to distinguish it from u !nc, which has 1 row and 3 columns.\nNow look up the commands length and size in the help files:\nhelp length help size Matrices Matrices in MATLAB are $m\\times n$ arrays of numbers.\nWalkthrough Suppose the matrix $A$ is given by: $$A=\\begin{pmatrix}1\u0026amp;2\\\\3\u0026amp;4\\end{pmatrix}$$\nThis may be entered into MATLAB in either of the following ways:\n  By entering each entry of the matrix individually\nA(1,1)=1; A(1,2)=2; A(2,1)=3; A(2,2)=4;   Note The entry $A(i,j)$ corresponds to the entry in row $i$ and column $j$ of the matrix $A$.\n  By typing\nA=[1 2; 3 4];   Note Use of ; !nc inside the square brackets denotes a new row in the matrix.\n The dimensions of a matrix A !nc can be found by using the command size(A), which here gives\n\u0026gt;\u0026gt; size(A) ans = 2 2  Note Running the command length(A) on a matrix A !nc yields the result 2, which is the bigger dimension of the matrix, so if A !nc were a $4\\times 6$ or a $6\\times 4$ matrix, length(A) would yield the answer 6.\n Editing vectors and matrices Walkthrough Editing vectors and matrices can be done by specifying the individual element. For example, to change the value of 2 in the matrix A !nc, above, to 5 we can type\nA(1,2)=5; An alternative method is to double-click on A !nc in the Workspace window. This opens a window containing the contents of the matrix A !nc. Click on the entry in the first row, second column, and change it to 5.\nLooking at parts of matrices Sometimes we may wish to access only certain parts of a matrix or vector. There are a number of inbuilt MATLAB commands to help with this.\nWalkthrough The matrix $$C=\\begin{pmatrix}1\u0026amp;2\u0026amp;3\u0026amp;4\\\\5\u0026amp;6\u0026amp;7\u0026amp;8\\\\9\u0026amp;10\u0026amp;11\u0026amp;12\\end{pmatrix}$$\nmay be entered in MATLAB as\nC=[1 2 3 4; 5 6 7 8; 9 10 11 12]; To view the whole matrix we would type\nC To view the second column we would type\nC(:,2) To view the third row we would type\nC(3,:) To view the first two rows we would type\nC(1:2,:) To view the elements in both the last two rows and the last three columns we would type\nC(2:3,2:4)  Note The following: C(2:end,2:end) would yield the same result.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/07_exercises_1/",
	"title": "Exercises 1",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/07_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/07_exercises_3/",
	"title": "Exercises 3",
	"tags": [],
	"description": "",
	"content": " Question Let $f(x) = x^3 - 1 $.\n  Use the bisection method on the interval $[−1,10]$ to calculate the root of $f(x)=0$ correct to two decimal places. How many bisections were necessary?\n  Use Newton–Raphson with $x_0=10$ to calculate the root of $f(x)=0$ correct to two decimal places. How many iterations were necessary?\n   Expand for solution Solution   14 bisections are required for interval bisection:\nclear all % % Interval bisection method % Firstly define the ends of the interval [-1,10] a=-1; b=10; NumberOfBisections=0; % Initialising % while (b-a \u0026gt; 0.001) % Want root correct to 2 decimal places c=(a+b)*0.5; f0=a^3-1; % function evaluated at a f1=c^3-1; % function evaluated at c f2=b^3-1; % function evaluated at b if (f0*f1 \u0026gt; 0) a=c; elseif (f0*f1 \u0026lt; 0) b=c; else b=a; end % % Increment number of bisections NumberOfBisections=NumberOfBisections+1; end % root = c NumberOfBisections   9 iterations are required for Newton–Raphson. Example code to solve this is given below:\nclear all % % Newton-Raphson method % x=10; % Approximation to solution, x0 diff=1; % Initialising NumberOfIterations=0; % Initialising % while ( diff \u0026gt;= 0.001 ) y=x-(x^3-1)/(3*x*x); diff=abs(y-x); % calculate |x_(n+1) - x_n| x=y; % Update solution approximation % % Increment number of iterations NumberOfIterations=NumberOfIterations+1; end % root = x NumberOfIterations      Question  Repeat the previous question for $f(x)=x^5+ \\frac{x}{1000000}$.   Expand for hint Hint Modify the code from the previous answer. All you need to change is the function definitions.\n  Comment on the convergence speed for Newton–Raphson in this question in comparison with that in the previous question. What is the reason for the difference.   Expand for solution Solution 14 bisections are required for the bisection method and 23 iterations are required for Newton–Raphson in this case.\n  Example code to solve this using the bisection method is given below:\nclear all % % Interval bisection method % Firstly define the ends of the interval [-1,10] a=-1; b=10; NumberOfBisections=0; % Initialising % while (b-a \u0026gt; 0.001) % Want root correct to 2 decimal places c=(a+b)*0.5; f0=a^3-1; % function evaluated at a f1=c^3-1; % function evaluated at c f2=b^3-1; % function evaluated at b if (f0*f1 \u0026gt; 0) a=c; elseif (f0*f1 \u0026lt; 0) b=c; else b=a; % end % % Increment number of bisections NumberOfBisections=NumberOfBisections+1; end % root = c NumberOfBisections Example code to solve this using Newton–Raphson is given below:\nclear all % % Newton-Raphson method % x=10; % Approximation to solution, x0 diff=1; % Initialising NumberOfIterations=0; % Initialising % while ( diff \u0026gt;= 0.001 ) y=x-(x^5-x/1000000)/((4*x^4)+1/1000000); diff=abs(y-x); % calculate |x_(n+1) - x_n| x=y; % Update solution approximation % % Increment number of iterations NumberOfIterations=NumberOfIterations+1; end % root = x NumberOfIterations   The convergence speed is slower for Newton–Raphson because the derivative of this function is very small in the region of the root.\n     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/07_solving_axb_iterative/",
	"title": "Solving $Ax=b$: iterative",
	"tags": [],
	"description": "",
	"content": "This section is appropriate if you have a background in mathematics and have encountered matrices before. If not then feel free to attempt this section however the material assumes a relatively high level of knowledge of linear algebra.\nMATLAB has many inbuilt methods for solving $Ax=b$. Many of these are iterative and suitable for different kinds of matrices. If you have information about the structure of $A$ and know which iterative solver is the best to use (see Linear Algebra and its Applications by Gilbert Strang for details), you can specify the solver in MATLAB. The help files will specify the types of matrix to which they should be applied. We will now use two of these solvers based on the \u0026lsquo;conjugate gradient\u0026rsquo; method.\nWalkthrough Create a Symmetric Positive Definite (SPD) matrix (and check that it is SPD) by using the following commands:\nA=randn(50); % Make sure A is SPD A=A*A\u0026#39;; % Verify that this gives us a symmetric matrix spy(A-A\u0026#39;) find((A-A\u0026#39;)\u0026gt;1e-10) % check positive definite: all eigenvalues \u0026gt; 0 e=eig(A); min(e) Create a suitable right-hand side $b$:\nb=sum(A,2);  Question With $A$ and $b$ defined as above, what is the exact solution to $Ax=b$?\n Expand for solution Solution Every element of $x$ should be exactly 1. If this is not clear, make sure you understand what sum(A,2) is doing, and try writing out a 3x3 system by hand.\n   Calculate $x$ using the preconditioned Conjugate Gradient method (CG) (see Linear Algebra and its Applications by Gilbert Strang for details if you are interested). Note that $A$ must be SPD to use this solver. Try using it on a non-SPD matrix.\nx1=pcg(A,b); x2=pcg(A,b,1e-6,100); What does the second command do differently? Look at doc pcg. Now look at the solutions:\nformat long max(abs(x1-x2)) plot(x1-x2) This gives the following figure for the error $x1-x2$:\nwhich shows that the solutions are not the same.\nQuestion Why is this?\n Expand for solution Solution When running the command\nx1=pcg(A,b); you should have received the following output:\n\u0026gt;\u0026gt; x1=pcg(A,b); pcg stopped at iteration 20 without converging to the desired tolerance 1e-06 because the maximum number of iterations was reached. The iterate returned (number 19) has relative residual 0.0019. Therefore the method did not converge in the given maximum number of steps. It defaults to 20. The command\nx2=pcg(A,b,1e-6,100); sets the maximum number of iterations at 100, which is enough for the method to converge.\n   Now clear the workspace\nclear The Biconjugate Gradient method can be used in a similar way. Note that $A$ does not have to be SPD in this case.\nA=randn(50); b=sum(A,2); x=bicg(A,b,1e-6,100); plot(x) Now clear the workspace\nclear To learn more about these iterative methods, see:\ndoc pcg doc bicg doc bicgstab doc gmres "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/07_vectors_and_matrices_part_2/",
	"title": "Vectors and matrices: part 2",
	"tags": [],
	"description": "",
	"content": "Now that we know how to handle matrices and vectors in MATLAB, we will look at how to perform operations on them.\nAddition, subtraction and multiplication of vectors and matrices If two vectors or matrices are of the correct size, then they may be added, subtracted or multiplied using the standard operators + !nc, - !nc and * !nc.\nWalkthrough For example, enter the following vectors and matrices:\nu=[1 2]; v=[3; 4]; A=[1 2; 3 4]; B=[5 6; 7 8]; The following are valid operations:\nu*v v*u A+B A-B A*B A*v u*A (A+B)*v but\nA*u is not. Try entering the above operations in the command line.\nQuestion What do the above operations represent and what is the result: a matrix; a vector; or a scalar?\n Expand for solution  u*v – inner product (dot product) – scalar (1 x 1). v*u – vector outer product – matrix (2 x 2). A+B – matrix addition – matrix (2 x 2). A-B – matrix subtraction – matrix (2 x 2). A*B – matrix multiplication – matrix (2 x 2). A*v – right multiplication of a matrix by a vector – vector (2 x 1). u*A – left multiplication of a matrix by a vector – vector (1 x 2). (A+B)*v – matrix addition and right multiplication – vector (2 x 1).    Question Why is A*u not a valid operation?\n Expand for solution The product A*u would represent right multiplication of a 2 x 2 matrix by a 1 x 2 vector, which is an incompatible matrix multiplication. The appropriate dimensions must agree to use the * !nc operator. Similarly, v*A would also fail.\nAttempting an incompatible matrix multiplication will result in an error like this:\n\u0026gt;\u0026gt; A*u Error using * Incorrect dimensions for matrix multiplication. Check that the number of columns in the first matrix matches the number of rows in the second matrix.    Element-wise operations Often we wish to perform operations on elements of a vector or a matrix. We may, for example, have a vector of numbers and wish to calculate their squares. This is done using the \u0026lsquo;dot\u0026rsquo; command, '.' !nc\nWalkthrough For example, enter the following vectors:\nu=[1 2 3 4]; v=[5 6 7 8]; To calculate the square of all elements of u !nc use the command:\nu.^2 To multiply each element of u !nc by the corresponding element of v !nc use:\nu.*v This also works with matrices, for example:\nA.^2  Note This only works if the sizes of the vectors/matrices are the same. It is good practice to clear your variables once you have finished using them.\n Generating vectors It can be tedious to input vectors by specifying all the entries manually; the following are two methods to define vectors more quickly.\nWalkthrough A row vector x !nc consisting of integers from 1 to 10 inclusive may be generated by typing:\nx=1:10 Furthermore, a row vector x !nc consisting of every odd integer from 1 to 9 inclusive may be generated by typing\nx=1:2:9 The central variable indicates the step size, so\nx=10:-1:1 would yield a row vector consisting of the integers from 1 to 10 inclusive, but in descending order.\nA vector y !nc consisting of 100 points equally spaced between 5 and 15 may be generated by typing\ny=linspace(5,15,100) look up the linspace command in the MATLAB help system.\nSome special matrices and vectors MATLAB has inbuilt commands that can be used to create some simple matrices, which can be adapted using your own code to construct matrices of interest to you. You will see examples of this in later units.\nWalkthrough The 3 x 4 matrix with all entries equal to 0 may be produced using the command\nzeros(3,4) The 5 x 2 matrix with all entries equal to 1 may be produced using the command\nones(5,2) The 4 x 6 matrix with diagonal entries equal to 1 and all other entries equal to 0 is given by\neye(4,6) The 2 x 1 matrix (that is, a column vector of length 2) with entries that are distributed randomly with a uniform distribution on the interval $[0,1]$ is given by\nrand(2,1) The 1 x 3 matrix (that is, a row vector of length 3) with entries uniformly distributed with mean 0 and standard deviation 1 is given by\nrandn(1,3) If the matrix required with any of the commands in this section is square, then the second index is not required, as for example with\nones(4) rand(2) "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/08_complex_numbers/",
	"title": "Complex numbers",
	"tags": [],
	"description": "",
	"content": " Info MATLAB can also handle complex numbers. If you have never heard of these before, then look them up in:\n an A-level textbook, on the Wolfram MathWorld pages, or on Wikipedia  before you continue.\n Walkthrough Complex numbers may be entered as, for example,\nz=3+4i The real part, imaginary part, magnitude, argument (in radians) and complex conjugate of z may be evaluated using the following commands:\nreal(z) imag(z) abs(z) angle(z) conj(z)  Question Question: What are the results of the above operations?\n Expand for solution  real(z) = 3. imag(z) = 4. abs(z) = 5. angle(z) = 0.9273. conj(z) = 3-4i.    "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_4_linear_algebra/08_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": "The following exercise is the final one in the unit and it will allow you to practise using MATLAB to solve linear systems and give you an insight into which methods to use.\nLet $A$ be a sparse symmetric positive definite matrix of dimension $(N-1)^2\\times (N-1)^2$ defined in buildA.m !nc from the previous question, and let $f$ be the vector of dimension $(N-1)^2$ entered in MATLAB (for a given $N$) by the function:\nfunction f=buildf(N) x=0:1/N:1; y=x; f=sin(pi*x)\u0026#39;*sin(pi*y); f=reshape(f(2:N,2:N),(N-1)^2,1); end Copy this function to a file called buildf.m in your current working directory.\nIn this exercise we will consider the solution of the linear system $Au=f$, which corresponds to a finite difference solution to Poisson\u0026rsquo;s equation $-\\nabla^2u=f$ on the unit square, with zero Dirichlet boundary conditions, where $f=\\sin(\\pi x)\\sin(\\pi y)$. Partial differential equations of this type occur very frequently (usually with some additional reaction and or convection terms) in mathematical modelling of physical and biological processes, and even in image analysis.\nQuestion For $N=4,\\,8,\\,16,\\,32,\\,64,\\,128,\\,256,\\,512$, try the following:\n Solve the linear systems $Au=f$ by explicitly calculating $A^{-1}$ and calculating $u=A^{-1}f$ and record the time this takes on a log–log graph. (Omit the cases $N=128,\\,256,\\,512$ as the program may run out of memory or take an awfully long time.)   Expand for hint Hint You may wish to use the following code from the earlier walkthrough as a starting point:\n% we will perform 20 repeats on 12 problem sizes num_repeats=20; num_problems=12; % % 2, 4, 8, 16, ..., 4096 problem_sizes=2.^(1:num_problems); % % pre-allocate two matrices to store the times in times_inv=zeros(num_repeats,num_problems); times_slash=zeros(num_repeats,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); for repeat=1:num_repeats % create the random matrix A and vector b A=randn(problem_size); b=randn(problem_size,1); % time the two methods of solving Ax=b tic; x1=inv(A)*b; times_inv(repeat,problem)=toc; tic; x2=A\\b; times_slash(repeat,problem)=toc; end end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,mean(times_inv),\u0026#39;rx\u0026#39;,... problem_sizes,mean(times_slash),\u0026#39;bo\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to solve a matrix problem using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;)    Solve the linear systems using Gaussian elimination (corresponding to MATLAB\u0026rsquo;s \\ !nc command). Plot the time this takes on the same graph.   Expand for solution Solution The following MATLAB code calculates both of these and plots them on the same graph:\n% no repeats this time: the matrices are not random num_problems=8; % % 4, 8, 16, ..., 512 problem_sizes=2.^(2:1+num_problems); % % pre-allocate a matrix to store the times times=zeros(2,num_problems); % for problem=1:num_problems problem_size=problem_sizes(problem); % create the A and f A=buildA(problem_size); f=buildf(problem_size); % time the two methods of solving Au=f if problem_size\u0026lt;128 tic; u1=inv(A)*f; times(1,problem)=toc; end tic; u2=A\\f; times(2,problem)=toc; end % % Plot a log-log plot of average time vs problem size loglog(problem_sizes,times(1,:),\u0026#39;x-\u0026#39;,... problem_sizes,times(2,:),\u0026#39;o-\u0026#39;) ylabel(\u0026#39;Elapsed time\u0026#39;) title(\u0026#39;Comparison of times to linear system using inv and backslash\u0026#39;) legend(\u0026#39;inv(A)*b\u0026#39;,\u0026#39;A\\\\b\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) This yields the following figure:\nNote that backslash is faster than calculating the inverse explicitly for all problem sizes bigger than $N=4$, and backslash solves the $(N-1)^2\\times (N-1)^2$ system even for $N=512$ in under a second.\nCalculating the inverse fails for $N=128$ is infeasible in a sensible amount of time.\n   "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/08_fourier_series/",
	"title": "Fourier series",
	"tags": [],
	"description": "",
	"content": "Fourier series can be used to approximate a general periodic function, even with discontinuities. It does this by using the sum of continuous sine and cosine waves.\nSummary of mathematics used The Fourier series of the periodic function $f(x)$ defined on the domain $[−\\pi,\\pi]$ such that $f(x)+f(x+2\\pi)$ is given by:\n$$f(x) = \\frac{1}{2}a_0 + \\sum_{n=1}^{\\infty} \\left( a_n\\cos{nx} + b_n\\sin{nx} \\right)$$\nwhere\n$$a_0 = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\,dx$$\nand\n$$a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\cos{nx}\\,dx \\textrm{, and} \\quad b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(x)\\sin{nx}\\,dx \\quad \\textrm{for}\\, n = 1,2,\\ldots.$$\nThis formula can be extended to functions with an arbitrary period. In addition, any function defined on an interval $[a,b]$ can be extended to a periodic function, with period $b−a$, for which a Fourier series can be calculated. For more details on the mathematics underlying Fourier series see https://mathworld.wolfram.com/FourierSeries.html and the references contained within it.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/08_initial_value_problems/",
	"title": "Initial value problems",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/08_making_movies_in_matlab/",
	"title": "Making movies in MATLAB",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/09_exercises_3/",
	"title": "Exercises 3",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_3_basic_calculus/09_exercises_4/",
	"title": "Exercises 4",
	"tags": [],
	"description": "",
	"content": " Question Verify analytically that the Fourier series of a square wave defined as:\n$$f(x) = \\left\\{ \\begin{array}{ll} -k \u0026amp; \\textrm{if}\\quad -\\pi\u0026lt;x\u0026lt;0\\,, \\\\ k \u0026amp; \\textrm{if}\\quad 0\u0026lt;x\u0026lt;\\pi\\,, \\end{array} \\right. $$\nand\n$$f(x+2\\pi) = f(x)$$\nis\n$$\\frac{4k}{\\pi}\\left( \\sin{x} + \\frac{1}{3}\\sin{3x} + \\frac{1}{5}\\sin{5x} + \\ldots \\right).$$\n Expand for soluton Solution $$a_0 = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\,dx = 0 $$ $$a_n = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\cos{nx}\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\cos{nx}\\,dx = 0\\, , \\quad \\textrm{for} \\quad n=1,2,\\ldots $$ and $$b_n = \\frac{-1}{\\pi}\\int_{-\\pi}^0 k\\sin{nx}\\,dx + \\frac{1}{\\pi}\\int_0^{\\pi} k\\sin{nx}\\,dx = \\frac{4k}{n\\pi}\\,, \\quad \\textrm{for} \\quad n=1,3,5,\\ldots $$ and\n$$b_n = 0 \\quad \\textrm{for} \\quad n = 2,4,6,\\ldots.$$\n   Question   Write MATLAB code to sum the first components of the series calculated in the question above, for increasing values of $N$, to see how the series converges.\n  The lack of convergence at the discontinuities is known as Gibbs\u0026rsquo;s phenomenon, and the mathematical explanation dates back to the beginning of the twentieth century. Quantify Gibbs\u0026rsquo;s phenomenon and give a mathematical explanation for it. (There\u0026rsquo;s a good one on Wikipedia.)\n   Expand for solution Solution   The following code will sum this series and plot the sum for $N=0,1,5,100$:\n% Plot the sum of the first N components of the Fourier series. clear close all % N=100; % Number of terms to include in series k=1; % Parameter for f % x=linspace(-pi,pi,1000); y=zeros(N+1,length(x)); % initialise the series % y(1,:)=4*k/pi*sin(x); % first term % Add on terms in the series for n=2:N y(n,:)=y(n-1,:)+4*k/(2*n-1)/pi*sin((2*n-1)*x); end % plot(x,y(1,:),x,y(5,:),x,y(10,:),x,y(100,:)); legend(\u0026#39;N=1\u0026#39;,\u0026#39;N=5\u0026#39;,\u0026#39;N=10\u0026#39;,\u0026#39;N=100\u0026#39;,\u0026#39;location\u0026#39;,\u0026#39;NorthWest\u0026#39;) The code yields the following plot\nwhich shows the convergence of the series to the square wave function $f(x)$.\n  The magnitude of the error of the Fourier series solution (the overshooting near the discontinuity) is the same as $N\\to\\infty$, but the width of the overshoot does tend to zero as $N\\to\\infty$. You can see this from the above figure.\n     "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/09_simple_m_files_scripts/",
	"title": "Simple M-files: scripts",
	"tags": [],
	"description": "",
	"content": "Instead of typing the commands into the Command Window, they may be typed into a file with a .m !nc extension, which allows commands to be built up into a high-level computer program.\nInfo Most of the time when you use MATLAB, you will write scripts, which are just text files with a .m !nc extension, rather than typing commands directly into the Command Window.\n Opening a new M-file From the \u0026lsquo;Home\u0026rsquo; tab, click \u0026lsquo;New Script\u0026rsquo;, or, from the \u0026lsquo;Editor\u0026rsquo; tab, select \u0026lsquo;New\u0026rsquo; and then \u0026lsquo;Script\u0026rsquo;.\nThis will open a new window that is a text editor. You can also type the following command in the Command Window:\nedit to open the MATLAB editor.\nWriting an M-file In a MATLAB script, you can type exactly the commands that you type into the Command Window, but you can write and run multiple commands at once. In the text editor type the following lines of code:\nA=[1 2; 3 4] B=[5 6; 7 8] C=A+B Click on the \u0026lsquo;Save\u0026rsquo; button on the toolbar and save the file as\nmymfile.m Running the M-file Return to the Command Window and type\nmymfile This has the same output as if you had entered the three lines of the M-file in the Command Window.\nWarning You must make sure not to name your file the same as a pre-existing MATLAB function. You can use the exist command (see doc exist) to find out if your function name is being used for an existing function.\n Breaking code across multiple lines While writing M-files you will often have to write long lines of code like:\nA=2*eye(500)-diag(ones(499,1),1)-diag(ones(499,1),-1); In order to make it easier to see what the code is doing and to prevent artificial line breaks (where the editor decides where to break the code across multiple lines) you can use the following:\nA=2*eye(500) ... ; -diag(ones(499,1),1) ... ; -diag(ones(499,1),-1); The dots ... !nc indicate that we wish to continue the current line of code on the next line of the file, when you run the file it is as if all the commands are on the same line.\nComments If you are writing lots of different M-files it is handy to insert comments into the code. Anything in the M-file preceded by a % !nc will be ignored when the M-file is executed. For example, the following code runs exactly the same commands as the mymfile.m file we created earlier.\n%%% Code to add two matrices together %%% A=[1 2; 3 4] % the first matrix B=[5 6; 7 8] % the second matrix % The sum of the two matrices C=A+B "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/09_speeding_up_code_part_1/",
	"title": "Speeding up code: part 1",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/10_boundary_value_problems/",
	"title": "Boundary value problems",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/10_flow_control/",
	"title": "Flow control",
	"tags": [],
	"description": "",
	"content": "For loops If a collection of statements need to be executed a fixed number of times, a for loop may be used.\nWalkthrough For example, the following commands print out the integers between 1 and 10 inclusive:\nfor i=1:10 i end While loops If a collection of statements need to be executed until a stopping criteria is reached a while loop may be used.\nWalkthrough For example the following commands print out the integers between 1 and 10 inclusive:\ni=1; while ( i \u0026lt;= 10 ) i i=i+1; end Operators that may be useful when using while loops are\n == – equal to (note that this is not the same as a single ‘=’ which is used to assign variables) ~= – not equal to \u0026lt; – less than \u0026gt; – greater than \u0026lt;= – less than or equal to \u0026gt;= – greater than or equal to  If statements If a given statement only needs to be executed under a given condition, an if statement may be used.\nWalkthrough For example, the following statements print out the variable x !nc if x !nc is negative:\nif (x\u0026lt;0) x end "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/10_speeding_up_code_part_2/",
	"title": "Speeding up code: part 2",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_6_software_engineering/11_exercises_2/",
	"title": "Exercises 2",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_5_solving_odes/11_exercises_4/",
	"title": "Exercises 4",
	"tags": [],
	"description": "",
	"content": " Warning Page under construction.\n "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/11_simple_graphics/",
	"title": "Simple graphics",
	"tags": [],
	"description": "",
	"content": "MATLAB incorporates many powerful graphic tools and can provide visualisations in two or three dimensions, and most books on MATLAB have whole chapters devoted to producing graphics.\nSingle plots We will now go through how to plot a simple function in MATLAB and save the figure to a file you can use in a report.\nWalkthrough To plot the function $\\sin(x)$ for $x$ between 0 and 10 type:\nfplot(@(x)sin(x),[0 10]) Here, the notation @(x)sin(x) !nc is referred to in MATLAB as an anonymous function. It specifies a function that takes x !nc and outputs sin(x) !nc.\nThis gives you the following figure on screen:\nTo label the axes and add a title type\nxlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39;) title(\u0026#39;y=sin(x)\u0026#39;) which updates the figure as follows:\nYou can save the figure by clicking on the \u0026lsquo;Save\u0026rsquo; icon in the top left corner of the screen. This will save the figure as a .fig !nc file which can only be opened in MATLAB.\nIf you want to save the file in a format that you can include in a report, select the \u0026lsquo;Save As\u0026rsquo; item in the \u0026lsquo;File\u0026rsquo; menu. You can select the type of file to save as in the \u0026lsquo;Save as type:\u0026rsquo; drop-down menu. The best file type to save the figure as are .eps !nc if you are using LaTeX, a .png !nc or .tiff !nc if you are using something like Microsoft Word, or .svg !nc if you are writing for the web.\nThe figure produced is given below:\nThere are also command line commands such as\nprint ExampleFigure.png –dpng which will print the currently selected figure to the file ExampleFigure.png !nc. The second command –dpng !nc selects the type of file in which the figure will be saved - try doing this now. For more options see\ndoc print To close the figure use the close command.\nMultiple plots You can also include multiple plots in the same figure, using the procedure covered in the following walkthrough.\nWalkthrough To plot two data-sets y1 !nc and y2 !nc against x !nc on the same diagram, use the method shown below.\nx=[1 2 3 4 5 6]; y1=[1 4 9 16 25 36]; y2=[6 5 4 3 2 1]; plot(x,y1, \u0026#39;-\u0026#39;,x,y2,\u0026#39;--\u0026#39;) xlabel(\u0026#39;x\u0026#39;) ylabel(\u0026#39;y\u0026#39; ) legend(\u0026#39;y1\u0026#39;,\u0026#39;y2\u0026#39;,\u0026#39;Location\u0026#39;,\u0026#39;NorthWest\u0026#39;) The statement plot(x,y1,'-',x,y2,'--') tells MATLAB to plot y1 !nc against x !nc as a solid line, and to plot y2 !nc against x !nc as a broken line. Note the use of legend to label the lines and the position of the legend.\nYou could also use the command hold on. To do this see doc hold for examples.\nThe text size on the axes and other properties of the figure can easily be altered. There are a number of options available under \u0026lsquo;View\u0026rsquo; including \u0026lsquo;Plot Edit Toolbar\u0026rsquo; and \u0026lsquo;Figure Palette\u0026rsquo; which bring up a number of options as shown here:\nIt is very important that the axes and labels on a figure are readable when you use the figure in a report, and you can use the plot tools to ensure this. To change the size of the text, just click on the text you wish to resize and you can then edit the font. All other properties of the figure can be changed using the plot tools.\nSubfigures You can also make multiple subplots in the same figure using the subplot command. Look it up now in the help files before continuing.\nWalkthrough To plot $sin(x)$ and $cos(x)$ in separate plots contained in the same figure we use the following commands:\nsubplot(1,2,1); fplot(@(x)sin(x),[0 10]); title(\u0026#39;y=sin(x)\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); subplot(1,2,2); fplot(@(x)cos(x),[0 10],\u0026#39;r\u0026#39;); title(\u0026#39;y=cos(x)\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); The statement subplot(1,2,1) tells MATLAB to create a grid of 1 by 2 subfigures within the main figure, and the last number indicates in which subfigure to put the next command. You can change these numbers to get a larger number of subfigures. You can add labels and titles to each of these subfigures in the usual way.\nThese commands result in the following figure:\nThe text size on the axes and other properties of the figure can easily be altered by selecting the options from the \u0026lsquo;View\u0026rsquo; menu, as with a single plot.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/12_plotting_3d_data/",
	"title": "Plotting 3D data",
	"tags": [],
	"description": "",
	"content": "MATLAB can also plot functions and data in 3D. The following commands are used to plot in 3D:\nplot3 surf mesh contour Before you continue, look at the help files for those commands.\nThe following walkthrough is an example of producing a plot of a 3D function.\nWalkthrough First create a mesh on which to plot the surface\nx = linspace(0,20,100); y = linspace(0,10,100); [X,Y] = meshgrid(x,y); Then define a surface by defining a \u0026lsquo;z-value\u0026rsquo; for each point on the mesh:\nZ=sin(X).*sin(Y); To view the surface in 3D use the commands:\nsurf(X,Y,Z) which gives:\nmesh(X,Y,Z) which gives:\ncontour(X,Y,Z) which gives:\nplot3(X,Y,Z) which gives:\nMany of the same tools and commands that worked in 2D plots (legend, title, etc) also work in 3D.\nTo close all figures at once you can use the close all command.\n"
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/13_functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": "A particularly useful feature of MATLAB is the ability to define functions.\nWalkthrough The syntax for defining the function $y=x^2$ is as follows:\nfunction [y] = xsquared(x) y = x^2;  Info  The [y] !nc indicates the variables that will be returned from the function: there may be multiple, e.g. [y1, y2] !nc. The (x) !nc indicates the parameters that are passed to the function: there may be multiple, e.g. (x1, x2) !nc.   Type these commands into an M-file called xsquared.m and save this file. Now type:\nxsquared(5) and then\nd=7; xsquared(d) Note that MATLAB also allows you to apply functions to arrays. To do this with the power function we modify the above by placing a '.' !nc before the '^' !nc in the above:\nfunction [y] = xsquared(x) y = x.^2; Now type on the command line\ne=[4,5,6]; xsquared(e) "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/unit_1_basic_introduction_to_matlab/14_exercises/",
	"title": "Exercises",
	"tags": [],
	"description": "",
	"content": "The unit closes with a few simple exercises for you to test the skills you have learned throughout the unit.\nQuestion Problem 1: Hint based problem\n Write functions to calculate the maximum and minimum of an array of numbers, without using the commands max !nc or min !nc. Your functions should take in a vector and return values for the maximum and minimum.   Expand for hint Hint The following if !nc statement will find the maximum between max_x !nc and x(i) !nc:\nif x(i)\u0026gt;max_x max_x=x(i); end    Combine the functions from part 1. to make one function that returns both the maximum and the minimum. See doc function for help on how to return multiple values.   Expand for solution Solution   The following code will calculate the maximum of an array passed to it:\nfunction [max_x] = maximum(x) max_x=x(1); for i=1:length(x) if x(i)\u0026gt;max_x max_x=x(i); end end The following code will calculate the minimum of an array passed to it.\nfunction [min_x] = minimum(x) min_x=x(1); for i=1:length(x) if x(i)\u0026lt;min_x min_x=x(i); end end To use these, save the above a .m !nc files with the appropriate names, and run the commands:\nminimum(x) maximum(x) where x !nc is a vector.\n  The following code will calculate the minimum and the maximum of an array passed to it:\nfunction [min_x,max_x] = minmax(x) min_x=x(1); max_x=x(1); for i=1:length(x) if x(i)\u0026lt;min_x min_x=x(i); end if x(i)\u0026gt;max_x max_x=x(i); end end To call the function, save the above as minmax.m !nc, and run:\n[minimum,maximum] = minmax(x)      Question Problem 2: Hint based problem\n Plot the functions $y=x^3$ and $y=x^5$, on the interval $[-2,\\,2]$, on the same graph. Where are the intersections of the curves?   Expand for hint Hint You may want to create the following vectors:\nx=linspace(-2,2,100); y1=x.^3; and use the plot functionality you learned in this unit.\n  Add a title and legend to the graph, label the axes, and save the figure as a .png !nc file.   Expand for solution Solution   Intersections occur at $(x,\\,y)=(−1,\\,−1),(0,\\,0),(1,\\,1)$. The following commands plot the curves:\nx=linspace(-2,2,100); y1=x.^3; y2=x.^5; plot(x,y1,\u0026#39;-\u0026#39;,x,y2,\u0026#39;--\u0026#39;);   The following commands will add a label and legend to the figure:\nlegend(\u0026#39;y=x^3\u0026#39;,\u0026#39;y=x^5\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); You can save the file by using \u0026lsquo;Save As\u0026rsquo; in the \u0026lsquo;File\u0026rsquo; menu or by using the following command.\nprint ExampleFigure.png -dpng      "
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://sabs-r3.github.io/ScientificComputingInMatlab/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]